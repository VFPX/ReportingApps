*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="frxbuilder.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS bandobjectviewer AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Grid1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: execute
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Caption = "Report Bands & Objects"
	Desktop = .T.
	DoCreate = .T.
	Height = 363
	MinButton = .F.
	Name = "bandobjectviewer"
	Width = 618
	grabber.Height = 11
	grabber.Left = 607
	grabber.Name = "grabber"
	grabber.Top = 351
	grabber.Width = 11
	frxcursor.Name = "frxcursor"

	ADD OBJECT 'Grid1' AS grid WITH ;
		Anchor = 10, ;
		FontName = "Lucida Console", ;
		FontSize = 9, ;
		Height = 160, ;
		Left = 6, ;
		Name = "Grid1", ;
		RowHeight = 15, ;
		Top = 19, ;
		Width = 602
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'Grid2' AS grid WITH ;
		Anchor = 15, ;
		FontName = "Lucida Console", ;
		FontSize = 9, ;
		Height = 149, ;
		Left = 6, ;
		Name = "Grid2", ;
		RowHeight = 15, ;
		Top = 203, ;
		Width = 602
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'Label1' AS label WITH ;
		Caption = "Bands:", ;
		FontName = "Tahoma", ;
		Height = 17, ;
		Left = 7, ;
		Name = "Label1", ;
		Top = 2, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		Caption = "Objects:", ;
		FontName = "Tahoma", ;
		Height = 17, ;
		Left = 6, ;
		Name = "Label2", ;
		Top = 185, ;
		Width = 56
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE Destroy
		dodefault()
		
		*--------------------------------------------------
		* Save size and position in resource:
		*--------------------------------------------------
		local x
		x = newobject("ResourceManager",FRXCOMMON_PRG_CLASSLIB)
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, BANDVIEWER_RESOURCE_NAME )
			x.SaveWindowState( THIS )
			x.SaveResource( REPORTBUILDER_RESOURCE_ID, BANDVIEWER_RESOURCE_NAME )
		endif
		release x
		
	ENDPROC

	PROCEDURE execute
		lparameter oEvent
		
		* Create run-time cursors:
		oEvent.frxCursor.CreateObjectCursor("","",.F.,.T.)
		
		go top in bands
		*go top in objects
		
		THIS.Grid1.RecordSource = "bands"
		THIS.Grid2.RecordSource = "objects"
		
		THIS.Show(1)
		
		*oEvent.SetHandledByBuilder(.T.)
		return
	ENDPROC

	PROCEDURE Init
		dodefault()
		THIS.MinWidth  = THIS.Width
		THIS.MinHeight = THIS.Height
		
		*--------------------------------------------------
		* Get size and position from resource:
		*--------------------------------------------------
		local x
		x = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, BANDVIEWER_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
		endif
		
	ENDPROC

	PROCEDURE QueryUnload
		THIS.Hide()
	ENDPROC

ENDDEFINE

DEFINE CLASS cbocalcreset AS cbo OF "frxcontrols.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: loadfromfrx
	*</DefinedPropArrayMethod>

	ColumnLines = .F.
	Name = "cbocalcreset"
	Width = 147
	
	PROCEDURE loadfromfrx
		*---------------------------------------------------------------------
		* LoadFromFrx()
		*
		* assumes:
		*  - the reset_on cursor has been created 
		*---------------------------------------------------------------------
		local curSel
		curSel = select(0)
		
		with THIS
		
			.Style       = 2   && dropdown list
		
			.Clear()
			.Value = 0
			
			select reset_on
			scan
				.AddListItem( PROMPT_TEXT, RESETTOTAL )
			endscan
		
			.DisplayCount = .ListCount
		endwith		
		
		
		select (m.curSel)
		return .T.
	ENDPROC

ENDDEFINE

DEFINE CLASS cbocalculate AS cbo OF "frxcontrols.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	DisplayCount = 8
	Name = "cbocalculate"
	Width = 160
	
	PROCEDURE Init
		dodefault()
		THIS.Style = 2 	&& dropdown list
		
		*-------------------------------------------------------------------
		* Calculation is usually 0-7. Those pesky zero-based enums....
		*-------------------------------------------------------------------
		
		THIS.AddItem( CALCULATE_NOTHING_LOC,  FRX_TOTALTYPE_NONE     + 1 )
		THIS.AddItem( CALCULATE_COUNT_LOC,    FRX_TOTALTYPE_COUNT    + 1 )
		THIS.AddItem( CALCULATE_SUM_LOC,      FRX_TOTALTYPE_SUM      + 1 )
		THIS.AddItem( CALCULATE_AVERAGE_LOC,  FRX_TOTALTYPE_AVERAGE  + 1 )
		THIS.AddItem( CALCULATE_LOWEST_LOC,   FRX_TOTALTYPE_LOWEST   + 1 )
		THIS.AddItem( CALCULATE_HIGHEST_LOC,  FRX_TOTALTYPE_HIGHEST  + 1 )
		THIS.AddItem( CALCULATE_STDDEV_LOC,   FRX_TOTALTYPE_STDDEV   + 1 )
		THIS.AddItem( CALCULATE_VARIANCE_LOC, FRX_TOTALTYPE_VARIANCE + 1 )
	ENDPROC

ENDDEFINE

DEFINE CLASS cntregfilter AS cnt OF "frxcontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboFilter" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: interactivechange		&& Occurs when the user changes the value of a control using the keyboard or the mouse.
		*m: refreshparent
	*</DefinedPropArrayMethod>

	BorderWidth = 0
	Height = 30
	Name = "cntregfilter"
	Width = 298

	ADD OBJECT 'cboFilter' AS cbo WITH ;
		Left = 2, ;
		Name = "cboFilter", ;
		Style = 2, ;
		Top = 3, ;
		Width = 272, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="combobox" />
	
	PROCEDURE Init
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_ALL)
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_HANDLERS)
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_FILTERS)
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_EXIT)
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_DIALOGS)
		THIS.cboFilter.AddItem(UI_REGEXPLR_FILTER_ENU_PROPERTIES)
		THIS.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_ALL
		
	ENDPROC

	PROCEDURE interactivechange		&& Occurs when the user changes the value of a control using the keyboard or the mouse.
		local cFilter, cObjTypes
		store "" to cFilter, cObjTypes
		do case
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_HANDLERS
			cFilter = "inlist(upper(REC_TYPE),'H',' ')"
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_FILTERS
			cFilter = "inlist(upper(REC_TYPE),'F',' ')"
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_EXIT
			cFilter = "inlist(upper(REC_TYPE),'X',' ')"
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_DIALOGS
			cFilter = "inlist(upper(REC_TYPE),'T','M','G','E','B','Y','Z','Q',' ')"
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_PROPERTIES
			cFilter = "inlist(upper(REC_TYPE),'P',' ')"
		
		endcase
		
		if not empty( m.cFilter )	
			set Filter to &cFilter in frxregistry
		else
			set Filter to in frxregistry
		endif
		go top
		THIS.RefreshParent()
		return 
		
	ENDPROC

	PROCEDURE refreshparent
	ENDPROC

	PROCEDURE cboFilter.InteractiveChange
		THIS.Parent.InteractiveChange()
	ENDPROC

ENDDEFINE

DEFINE CLASS debughandler AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="BrowsePanel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Command2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkRefresh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNoDefault" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Command1" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: execute
		*p: frxevent
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Caption = "Debug Handler"
	Desktop = .T.
	DoCreate = .T.
	frxevent = null
	Height = 350
	MinButton = .F.
	Name = "debughandler"
	Width = 464
	WindowType = 1
	grabber.Height = 11
	grabber.Name = "grabber"
	grabber.Width = 11
	frxcursor.Name = "frxcursor"

	ADD OBJECT 'BrowsePanel' AS panelfrxbrowser WITH ;
		Anchor = 15, ;
		Left = -4, ;
		Name = "BrowsePanel", ;
		TabIndex = 1, ;
		Top = 0, ;
		ZOrderSet = 1, ;
		Grid1.Name = "Grid1", ;
		Label1.Name = "Label1", ;
		Label3.Name = "Label3", ;
		Label4.Name = "Label4", ;
		Edit1.Name = "Edit1", ;
		Edit2.Name = "Edit2", ;
		Edit3.Name = "Edit3", ;
		Check1.Alignment = 0, ;
		Check1.Name = "Check1", ;
		Label5.Name = "Label5", ;
		Edit4.Name = "Edit4", ;
		Label6.Name = "Label6", ;
		Edit5.Name = "Edit5", ;
		Label7.Name = "Label7", ;
		Edit6.Name = "Edit6", ;
		Label8.Name = "Label8", ;
		Edit7.Name = "Edit7", ;
		Edit8.Name = "Edit8", ;
		Label9.Name = "Label9", ;
		Label2.Name = "Label2", ;
		Edit9.Name = "Edit9", ;
		Label10.Name = "Label10", ;
		Edit10.Name = "Edit10", ;
		Label11.Name = "Label11", ;
		Edit11.Name = "Edit11", ;
		Cmd1.Name = "Cmd1", ;
		Cmd2.Name = "Cmd2", ;
		Cmd3.Name = "Cmd3", ;
		Cmd4.Name = "Cmd4"
		*< END OBJECT: ClassLib="frxbuilder.vcx" BaseClass="container" />

	ADD OBJECT 'chkNoDefault' AS chk WITH ;
		Alignment = 0, ;
		Anchor = 12, ;
		Caption = "Suppress native event behavior (NODEFAULT)", ;
		Left = 132, ;
		Name = "chkNoDefault", ;
		Top = 292
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkRefresh' AS chk WITH ;
		Alignment = 0, ;
		Anchor = 12, ;
		Caption = "Refresh report layout from FRX cursor", ;
		Left = 132, ;
		Name = "chkRefresh", ;
		Top = 274
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdOptions' AS commandbutton WITH ;
		Anchor = 6, ;
		Caption = "Options...", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 10, ;
		Name = "cmdOptions", ;
		TabIndex = 3, ;
		Top = 306, ;
		Width = 108, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Command1' AS commandbutton WITH ;
		Anchor = 12, ;
		Caption = "Continue", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 360, ;
		Name = "Command1", ;
		TabIndex = 6, ;
		Top = 310, ;
		Width = 93, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Command2' AS commandbutton WITH ;
		Anchor = 6, ;
		Caption = "Event details...", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 10, ;
		Name = "Command2", ;
		TabIndex = 2, ;
		Top = 274, ;
		Width = 108, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Anchor = 12, ;
		BorderColor = 128,128,128, ;
		Height = 71, ;
		Left = 124, ;
		Name = "Shape1", ;
		Style = 3, ;
		Top = 269, ;
		Width = 336, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE execute
		*==========================================================================
		* Execute( oEvent )
		*
		* This class is not subclassed from frxHandlerForm, but rather, the generic
		* form superclass frxBaseForm. 
		* However, it does implement the Handler interface - Execute( obj )
		*==========================================================================
		lparameter oEvent
		
		*-------------------------------------------------------------------
		* Duplicate some code from frxHandlerBase::Execute()
		*-------------------------------------------------------------------
		THIS.frxEvent = oEvent
		
		THIS.Caption = "event: " ;
					 + upper(oEvent.getEventTypeText()) ;
					 + ", object: " ;
					 + upper(oEvent.getTargetTypeText()) 
		
		THIS.MinHeight = THIS.Height
		THIS.MinWidth  = THIS.Width
		THIS.Refresh()
		
		*------------------------------------------------------
		* Restore Preferences:
		*------------------------------------------------------
		local loRsc
		loRsc = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if loRsc.LoadResource( REPORTBUILDER_RESOURCE_ID, DEBUG_HANDLER_RESOURCE_NAME )
			loRsc.RestoreWindowState( THIS )
		endif
		
		*-------------------------------------------------------------------
		* It's a modal screen:
		*-------------------------------------------------------------------
		THIS.Show(1)
		
		*------------------------------------------------------
		* Save Preferences:
		*------------------------------------------------------
		loRsc.SaveWindowState( THIS )
		loRsc.SaveResource( REPORTBUILDER_RESOURCE_ID, DEBUG_HANDLER_RESOURCE_NAME )
		release loRsc
		
		*-------------------------------------------------------------------
		* Set return flags as specified by the user/UI:
		*-------------------------------------------------------------------
		oEvent.setReloadChanges(    THIS.chkRefresh.Value   )
		oEvent.setHandledByBuilder( THIS.chkNoDefault.Value )
		
		return
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		THIS.MinWidth  = THIS.Width
		THIS.MinHeight = THIS.Height
		THIS.HelpContextID = UI_DEBUGHNDLR_DLG_HELP_ID
	ENDPROC

	PROCEDURE QueryUnload
		*-------------------------------------------------------------
		* Clicking on the close box will continue execution after
		* the .Show() call in THIS.Execute()
		*-------------------------------------------------------------
		THIS.Hide()
	ENDPROC

	PROCEDURE chkNoDefault.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_DEBUG_CHK_FLAG_NODEFAULT
		#ENDIF
		
	ENDPROC

	PROCEDURE chkRefresh.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_DEBUG_CHK_FLAG_REFRESH
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdOptions.Click
		*-------------------------------------------------------------
		* This will invoke the Report Builder options dialog:
		*-------------------------------------------------------------
		THISFORM.frxEvent.showOptions()
	ENDPROC

	PROCEDURE cmdOptions.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_DEBUG_CMD_OPTIONS
		#ENDIF
		
	ENDPROC

	PROCEDURE Command1.Click
		*-------------------------------------------------------------
		* Clicking on the Continue button will continue execution after
		* the .Show() call in THIS.Execute()
		*-------------------------------------------------------------
		THISFORM.Hide()
		
	ENDPROC

	PROCEDURE Command1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_DEBUG_CMD_CONTINUE
		#ENDIF
		
	ENDPROC

	PROCEDURE Command2.Click
		*-------------------------------------------------------------
		* Process the event with the Event Inspector class:
		*-------------------------------------------------------------
		x = newobject("EventHookAlert", HANDLERS_PRG_CLASSLIB)
		x.Execute( THISFORM.frxEvent )
		return
	ENDPROC

	PROCEDURE Command2.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_DEBUG_CMD_DETAILS
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxbaseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grabber" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frxcursor" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: checkforlargefonts		&& Called in the Init() to set font attributes if Large Fonts are detected.
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	BorderStyle = 2
	Caption = "Form"
	DoCreate = .T.
	FontName = "Tahoma"
	FontSize = 8
	Height = 238
	Icon = images\wwrite.ico
	Name = "frxbaseform"
	Width = 367

	ADD OBJECT 'frxcursor' AS frxcursor WITH ;
		Height = 17, ;
		Left = 340, ;
		Name = "frxcursor", ;
		Top = 12, ;
		Width = 20
		*< END OBJECT: ClassLib="_frxcursor.vcx" BaseClass="custom" />

	ADD OBJECT 'grabber' AS resizegrabber WITH ;
		Height = 11, ;
		Left = 354, ;
		Name = "grabber", ;
		Top = 225, ;
		Visible = .F., ;
		Width = 11
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="image" />
	
	PROCEDURE Activate
		*====================================================================
		* Activate()
		*
		* Moves the "grabber" image to the bottom right corner and makes it 
		* visible if the form has a resizeable border.
		*====================================================================
		THIS.Grabber.Resize()
		THIS.Grabber.Visible = (THIS.BorderStyle = 3)
		
	ENDPROC

	PROCEDURE checkforlargefonts		&& Called in the Init() to set font attributes if Large Fonts are detected.
		*====================================================================
		* CheckForLargeFonts()
		*
		* This is invoked from the .Init() to set all contained objects to
		* use the "large font"-safe font, "MS Shell Dlg" which maps to the 
		* appropriate font in Windows.
		*
		*
		*====================================================================
		*----------------------------------------------------------------
		* Initial, default font setting:
		*----------------------------------------------------------------
		do case 
		case OS(3) = "6" or DEBUG_FORCE_SEGOE_UI
			THIS.SetAll("FontName","Segoe UI")
			THIS.SetAll("FontSize",9)
			THIS.SetAll("Margin",0,"txt")
			THIS.SetAll("Margin",0,"edt")
			THIS.SetAll("Margin",0,"Editbox")
			THIS.SetAll("Margin",0,"Textbox")
		
		case OS(3) = "5"
			THIS.SetAll("FontName","MS Shell Dlg 2")
			THIS.SetAll("FontSize",8)
		
		otherwise
			THIS.SetAll("FontName","Tahoma")
			THIS.SetAll("FontSize",8)
		
		endcase
		*----------------------------------------------------------------
		* Optional Fontname override:
		*----------------------------------------------------------------
		if not empty(DIALOG_FONTNAME_OVERRIDE)
			THIS.SetAll("FontName", DIALOG_FONTNAME_OVERRIDE )
			THIS.FontName = DIALOG_FONTNAME_OVERRIDE
		endif	
		
		*----------------------------------------------------------------
		* Adjustments for "large fonts":
		*----------------------------------------------------------------
		do case
		case DIALOG_FONTSIZE_OVERRIDE > 0
			*----------------------------------------------------------------
			* We can force the use of a specific font size:
			*----------------------------------------------------------------
			this.SetAll("FontSize", DIALOG_FONTSIZE_OVERRIDE )
			this.FontSize = DIALOG_FONTSIZE_OVERRIDE 
			
		*-----------------------
		* SP1 Fix: 
		*-----------------------
		case DEBUG_FORCE_LARGE_FONTS or ;
		     (DIALOG_ADJUST_FOR_LARGE_FONTS and this.frxCursor.ScreenDPI >= 120)
			*----------------------------------------------------------------
			* Use a slightly larger font in 120 dpi to match the other 
			* native VFP dialogs
			*----------------------------------------------------------------
			this.SetAll("FontSize", 10 )
			this.FontSize = 10
			
		endcase
		
	ENDPROC

	PROCEDURE Error
		*====================================================================
		* Error()
		*
		* Use the ErrorHandler class to provide default error handling. Most 
		* objects (in frxControls.vcx anyway) will defer error handling to their
		* containers, which ultimately ends up here:
		*====================================================================
		lparameters iError, cMethod, iLine
		
		local loErrorBox
		loErrorBox = newobject("ErrorHandler", FRXUTILS_PRG_CLASSLIB )
		loErrorBox.Handle( m.iError, m.cMethod, m.iLine, THIS )
		do case
		case loErrorBox.cancelled
			cancel
		case loErrorBox.suspended
			suspend
		endcase
		
		
		
		
	ENDPROC

	PROCEDURE Init
		*====================================================================
		* Init()
		*
		* Make sure that if large fonts are in effect, to switch all controls
		* to use a large-font-safe font.
		*====================================================================
		this.checkForLargeFonts()
		
	ENDPROC

	PROCEDURE Resize
		*====================================================================
		* Resize()
		*
		* Ensure the "grabber" image is anchored to the bottom right corner 
		* as the form is resized.
		*====================================================================
		THIS.Grabber.Resize()
	ENDPROC

ENDDEFINE

DEFINE CLASS frxbrowser AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Panelfrxbrowser1" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: execute
		*p: oevent
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Caption = "FRX Table Browser"
	Desktop = .T.
	DoCreate = .T.
	Height = 304
	MinButton = .F.
	Name = "frxbrowser"
	oevent = .NULL.
	Width = 461
	grabber.Height = 11
	grabber.Name = "grabber"
	grabber.Width = 11

	ADD OBJECT 'cmdOK' AS cmd WITH ;
		Anchor = 12, ;
		Cancel = .T., ;
		Caption = "OK", ;
		Height = 23, ;
		Left = 344, ;
		Name = "cmdOK", ;
		Top = 272, ;
		Width = 103
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Panelfrxbrowser1' AS panelfrxbrowser WITH ;
		Anchor = 15, ;
		Left = -4, ;
		Name = "Panelfrxbrowser1", ;
		Top = 0, ;
		Grid1.Name = "Grid1", ;
		Label1.Name = "Label1", ;
		Label3.Name = "Label3", ;
		Label4.Name = "Label4", ;
		Edit1.Name = "Edit1", ;
		Edit2.Name = "Edit2", ;
		Edit3.Name = "Edit3", ;
		Check1.Alignment = 0, ;
		Check1.Name = "Check1", ;
		Label5.Name = "Label5", ;
		Edit4.Name = "Edit4", ;
		Label6.Name = "Label6", ;
		Edit5.Name = "Edit5", ;
		Label7.Name = "Label7", ;
		Edit6.Name = "Edit6", ;
		Label8.Name = "Label8", ;
		Edit7.Name = "Edit7", ;
		Edit8.Name = "Edit8", ;
		Label9.Name = "Label9", ;
		Label2.Name = "Label2", ;
		Edit9.Name = "Edit9", ;
		Label10.Name = "Label10", ;
		Edit10.Name = "Edit10", ;
		Label11.Name = "Label11", ;
		Edit11.Name = "Edit11"
		*< END OBJECT: ClassLib="frxbuilder.vcx" BaseClass="container" />
	
	PROCEDURE Destroy
		dodefault()
		
		*--------------------------------------------------
		* Save size and position in resource:
		*--------------------------------------------------
		local x
		x = newobject("ResourceManager",FRXCOMMON_PRG_CLASSLIB)
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, FRXBROWSER_RESOURCE_NAME )
			x.SaveWindowState( THIS )
			x.SaveResource( REPORTBUILDER_RESOURCE_ID, FRXBROWSER_RESOURCE_NAME )
		endif
		release x
		
	ENDPROC

	PROCEDURE execute
		lparameter loEvent
		
		THIS.oEvent = m.loEvent
		
		local curRec
		select frx
		curRec = recno()
		
		THIS.Show(1)
		
		select frx
		if between(m.curRec,1,reccount())
			go m.curRec
		endif
		
		THIS.oEvent = .null.
		
		return
	ENDPROC

	PROCEDURE Init
		dodefault()
		THIS.MinWidth  = THIS.Width
		THIS.MinHeight = THIS.Height
		
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption   = UI_FRXBROWS_FORM_CAPTION_LOC
		#ENDIF
		THIS.HelpContextID = UI_FRXBROWS_DLG_HELP_ID
		
		*--------------------------------------------------
		* Get size and position from resource:
		*--------------------------------------------------
		local x
		x = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, FRXBROWSER_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
		endif
		
	ENDPROC

	PROCEDURE QueryUnload
		THIS.Hide()
	ENDPROC

	PROCEDURE cmdOK.Click
		*-----------------------------------------------------------------
		* Continues execution after the .Show()
		*-----------------------------------------------------------------
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdOK.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_OK_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxclassutil AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getbaseclassof		&& returns the base class of a given class name
		*m: getinstanceof		&& returns the instantiated object from a class name
		*p: errored		&& Set .T. in the .Error event.
		*p: errormessage
	*</DefinedPropArrayMethod>

	errormessage = 0
	Name = "frxclassutil"
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		*-----------------------------------------
		* Fix for SP1: Report the error 
		*-----------------------------------------
		THIS.errorMessage = message()
		THIS.errored = .T.
		
	ENDPROC

	PROCEDURE getbaseclassof		&& returns the base class of a given class name
		*-------------------------------------------
		* Return the base class of a give class name:
		*-------------------------------------------
		lparameters cClass, cClassLib
		
		THIS.errored = .F.
		
		local x, cRetval
		x = newobject( m.cClass, m.cClassLib, 0 )
		if not THIS.errored
			if not isnull( x )
				cRetVal = x.baseclass
			endif
			release x
			return m.cRetVal
		else
			return .F. && this should notify the caller
		endif
		
	ENDPROC

	PROCEDURE getinstanceof		&& returns the instantiated object from a class name
		*-------------------------------------------
		* Return the instantiated object from a class name:
		*-------------------------------------------
		lparameters cClass, cClassLib
		
		THIS.errored = .F.
		local x, oRetval
		oRetVal = newobject( m.cClass, m.cClassLib )
		if THIS.Errored
			oRetVal = null
		endif
		return m.oRetVal
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxevent AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: browsebandobjects
		*m: browsefrx		&& displays the FRX cursor in a browsable dialog.
		*m: browsemetadata
		*m: browseregistry		&& Displays the handler registry table in a browsable dialog. Editable unless the registry table is read-only (as it is for the default internal one.)
		*m: closeregistry		&& Closes the registry table.
		*m: copyregistry		&& Used by the options dialog to copy out the internal table to an external copy, for customization. The destination file will be erased, if it exists.
		*m: editxmlmetadata
		*m: execute		&& This is the main framework logic, handling the event by looking up a handler class in the registry table, performing init code, cleanup code, etc.
		*m: geteventtypetext		&& Returns a readable string value version of an event type.
		*m: getexpression		&& Displays a GETEXPR dialog and returns a string containing the entered expression. Developers can replace the default GETEXPR wrapper with their own implementation, registered in the handler table.
		*m: getextensioneditor		&& returns a reference to an instance of the class defined in the reportbuilder handler registry as the Run-time extensions editor class.
		*m: getfrxbrowser
		*m: gethandlerregistryeditor
		*m: getlibraryappname
		*m: getlibraryfilename		&& returns the fully qualified file name of the specified partial class library file name. Parameter: cLibrary  (e.g. "plugins\mylib.prg")
		*m: getmemoryback		&& This switches into the default data session and checks to see if it can get hold of a reference to one created earlier. Stores a name-value pair collection as a property of _screen.
		*m: getregisteredobject		&& Parameters: cRecType [, cDefaultClass, cDefaultLib ]
		*m: getregistrytablename		&& Returns the fully qualified file name of the registry table.
		*m: gettargettypetext		&& Returns a readable string value version of an ObjectType+Code combination.
		*m: handle		&& This method handles the event by looking up a handler class in the registry table, and executing it. Assumes: the registry table is open (alias "frxregistry")
		*m: locateextensionclass
		*m: locatehandlerclass		&& Searches the handler registry table for a handler class that is registered to a specific combination of event type and target object, using progressively less selective search criteria in an attempt to get a match. Assumes: registry table is open.
		*m: multiselect_access
		*m: newregisteredobject
		*m: openregistry		&& Opens the registry table.
		*m: processedbyfilter		&& Processes any event filters and returns .T. if the event has been handled.
		*m: processexithandlers		&& Processes any exit handlers registered in the handler table.
		*m: sethandledbybuilder		&& Pass .T. to prevent the Report Designer from responding to the event with its default behavior.
		*m: setreloadchanges		&& Pass .T. to instruct the Report Designer to respect changes made to the FRX cursor.
		*m: showoptions		&& Displays the Report Builder options dialog.
		*m: tostring		&& Returns a string representation of the event properties.
		*p: advancedproperties
		*p: builderpath		&& Place to store the path to _REPORTBUILDER
		*p: commandclauses		&& REPORT... command clauses
		*p: defaultrecno		&& the incoming selected record of the FRX cursor
		*p: defaultsessionid		&& data session id of the Report Designer
		*p: eventtype		&& indicates the type of designer event that occurred
		*p: frxcursor		&& contains an instance of the frxCursor utility class
		*p: frxsessionid		&& data session ID of the FRX cursor/Builder
		*p: handlemode		&& Indicates how the builder handles events, retrieved from the VFP session-scoped data store
		*p: multiselect		&& .T. if multiple objects are selected in the Designer
		*p: objcode		&& object code of target/selected record
		*p: objtype		&& object type of target/selected record
		*p: protected		&& .T. if PROTECTED was specified on the command line.
		*p: returnflags		&& Value to be returned to the Designer.
		*p: selectedobjectcount		&& contains the number of object selected in the designer report layout
		*p: sessiondata		&& reference to a name-value collection, session-scoped data store
		*p: setuputils
		*p: uniqueid
		*p: unitconverter
		*p: usinginternalregistry
	*</DefinedPropArrayMethod>

	advancedproperties = .NULL.
	builderpath = ("")		&& Place to store the path to _REPORTBUILDER
	commandclauses = .NULL.		&& REPORT... command clauses
	defaultrecno = 0		&& the incoming selected record of the FRX cursor
	defaultsessionid = 0		&& data session id of the Report Designer
	eventtype = -1		&& indicates the type of designer event that occurred
	frxcursor = .NULL.		&& contains an instance of the frxCursor utility class
	frxsessionid = 0		&& data session ID of the FRX cursor/Builder
	handlemode = 1		&& Indicates how the builder handles events, retrieved from the VFP session-scoped data store
	Name = "frxevent"
	objcode = 0		&& object code of target/selected record
	objtype = 0		&& object type of target/selected record
	returnflags = 0		&& Value to be returned to the Designer.
	selectedobjectcount = 0		&& contains the number of object selected in the designer report layout
	sessiondata = .NULL.		&& reference to a name-value collection, session-scoped data store
	setuputils = .F.
	uniqueid = ("")
	unitconverter = .NULL.
	
	PROCEDURE browsebandobjects
		*=======================================================
		* BrowseBandObjects( [ frxFile ] )
		*
		* Displays the FRX cursor in a Band/Object dialog
		*=======================================================
		lparameter lcFrxFile
		
		if not used('frx')
			*-------------------------------------------------------
			* Use the filename specified. 
			*-------------------------------------------------------
			if empty( m.lcFrxFile)
				*-------------------------------------------------------
				* If no filename specified, prompt for one
				*-------------------------------------------------------
				lcFrxFile = getfile("FRX")
			else
				lcFrxFile = fullpath( m.lcFrxFile )
			endif
			if not file( m.lcFrxFile )
				=messagebox(RB_FILE_NOT_FOUND_LOC,0+64,DEFAULT_MBOX_TITLE_LOC)
				return
			endif
			
			local curSel, oRepBrowser
			curSel = select(0)
			
			select 0
			use (m.lcFrxFile) alias frx Noupdate
		
			oRepBrowser = newobject("bandobjectviewer",BUILDER_CLASSLIB)
			oRepBrowser.Caption = oRepBrowser.Caption + ": " + m.lcFrxFile
			oRepBrowser.Execute(THIS)
			release oRepBrowser
		
			use in frx
			select (m.curSel)
		
		else
			*-------------------------------------------------------
			* If the FRX is currently open, browse that.
			*-------------------------------------------------------
			select frx
			
			local oRepBrowser
			oRepBrowser = newobject("bandobjectviewer",BUILDER_CLASSLIB)
			oRepBrowser.Execute(THIS)
			release oRepBrowser
		
		endif
		return
		
	ENDPROC

	PROCEDURE browsefrx		&& displays the FRX cursor in a browsable dialog.
		*=======================================================
		* BrowseFrx( [ frxFile ] )
		*
		* Displays the FRX cursor in a browsable dialog
		*=======================================================
		lparameter tcFrxFile
		local lOpened
		*--------------------------------------
		* Fix for SP2:  Ensure registry is open
		*--------------------------------------
		if not used('frxregistry')
			lOpened = .T.
			this.openRegistry()
		endif
		
		local llFrxOpened, curSel, oRepBrowser
		llFrxOpened = .F.
		
		if not used('frx')
			*-------------------------------------------------------
			* Use the filename specified. 
			*-------------------------------------------------------
			if empty( m.tcFrxFile)
				*-------------------------------------------------------
				* If no filename specified, prompt for one
				*-------------------------------------------------------
				tcFrxFile = getfile("FRX")
			else
				tcFrxFile = fullpath( m.tcFrxFile )
			endif
			if not file( m.tcFrxFile )
				=messagebox(RB_FILE_NOT_FOUND_LOC,0+64,DEFAULT_MBOX_TITLE_LOC)
				return
			endif
			
			curSel = select(0)
			
			select 0
			use (m.tcFrxFile) alias frx Noupdate
		
			llFrxOpened = .T.
		else
			*-------------------------------------------------------
			* If the FRX is currently open, browse that.
			*-------------------------------------------------------
			select frx
		endif
		
		*--------------------------------------
		* New in SP1: 
		* Registry Editor can be replaced, so 
		* use this wrapper method rather than
		* an explicit class/library
		*--------------------------------------
		* New in SP2: Use a different method:
		*--------------------------------------
		oRepBrowser = this.GetRegisteredObject( ;
							HANDLREG_FRXBROWSE, ;
							"frxBrowser", BUILDER_CLASSLIB )
		
		if not isnull( m.oRepBrowser )
			*----------------------------------------------------
			* Enhanced for SP1:
			* Check that the API is supported:
			*----------------------------------------------------
			if pemstatus( oRepBrowser, "Execute", 5 )
				if not empty( m.tcFrxFile ) and pemstatus( oRepBrowser, "Caption", 5 )
					oRepBrowser.Caption = oRepBrowser.Caption + ": " + m.tcFrxFile
				endif
				oRepBrowser.Execute( THIS )
			else
				=messagebox( strtran(RB_ERROR_API_NOT_SUPPORTED_LOC,"{0}",oRepBrowser.Class);
						+chr(13)+RB_ERROR_CHECK_REGISTRY_LOC, 16, DEFAULT_MBOX_TITLE_LOC  )
			endif
			release oRepBrowser
		endif
		
		if m.llFrxOpened
			use in frx
			select (m.curSel)
		endif
		if m.lOpened
			THIS.closeRegistry()
		endif
		
		return
		
	ENDPROC

	PROCEDURE browsemetadata
		*========================================================
		* BrowseMetadata()
		*
		* New in SP2: Displays a Memberdata browser form.
		*========================================================
		local oForm, lOpened
		if not used('frxregistry')
			lOpened = .T.
			this.openRegistry()
		endif
		
		oForm = this.GetRegisteredObject( ;
						HANDLREG_METABROWSE, ;
						"frxMetaBrowser", "frxBuilder.vcx" )
		
		if not isnull( m.oForm )
			oForm.Execute()
		endif
		
		if m.lOpened
			THIS.closeRegistry()
		endif
		
	ENDPROC

	PROCEDURE browseregistry		&& Displays the handler registry table in a browsable dialog. Editable unless the registry table is read-only (as it is for the default internal one.)
		*=======================================================
		* BrowseRegistry()
		*
		* Displays the handler registry table in a browesable
		* dialog. Editable unless the registry table is read only.
		* (as it would be if the internal version was being used.)
		*=======================================================
		local oRegBrowser, lOpened
		if not used('frxregistry')
			lOpened = .T.
			this.openRegistry()
		endif
		
		*--------------------------------------
		* New in SP1: 
		* Registry Editor can be replaced, so 
		* use this wrapper method rather than
		* an explicit class/library
		*--------------------------------------
		* New in SP2: Use a different method:
		*--------------------------------------
		oRegBrowser = this.GetRegisteredObject( ;
						HANDLREG_REGEDIT, ;
						"frxRegBrowser", BUILDER_CLASSLIB )
		
		if not isnull( m.oRegBrowser)
		
			if THIS.usingInternalRegistry
				oRegBrowser.Caption = ;
					UI_REGEXPLR_FORM_CAPTION_LOC + " - " + ;
					UI_REGEXPLR_FORM_INTERNAL_LOC
			endif
		
			go top in frxregistry
		
			oRegBrowser.Execute(THIS)
			
		endif
		if m.lOpened
			THIS.closeRegistry()
		endif
		
	ENDPROC

	PROCEDURE closeregistry		&& Closes the registry table.
		*=======================================================
		* CloseRegistry()
		*
		*=======================================================
		if used('frxregistry')
			use in frxregistry
		endif
		return
		
	ENDPROC

	PROCEDURE copyregistry		&& Used by the options dialog to copy out the internal table to an external copy, for customization. The destination file will be erased, if it exists.
		*=======================================================
		* CopyRegistry()
		*
		* Used by the options dialog to copy out the internal
		* table to an external copy, for customization.
		*
		* Destination file will be erased, if it exists.
		*=======================================================
		lparameter tcDestFile
		
		local cFile, curSel, cCurDir, lFileSpecified
		
		if type( "m.tcDestFile" ) = "C"
			*--------------------------------------------------------
			* we've been given a specific destination:
			*--------------------------------------------------------
			cFile = m.tcDestFile
			lFileSpecified = .T.
		else
			*--------------------------------------------------------
			* Prompt for a destination file:
			*--------------------------------------------------------
			lFileSpecified = .F.
			
			*--------------------------------------------------------
			* Set the default to the same directory as the reportbuilder.app
			*--------------------------------------------------------
			cCurDir = set("DIRECTORY")
			cd (THIS.builderPath)
		
			*--------------------------------------------------------
			* Prompt for a place to save the file to. 
			* Use the preferential filename as a suggestion:
			*--------------------------------------------------------
			cFile = putfile( REGISTRY_TABLE_LOC, "reportbuilder.dbf","dbf" )
			cFile = lower( m.cFile )
		
			*--------------------------------------------------------
			* Restore the current directory
			*--------------------------------------------------------
			cd (m.cCurDir)
		
		endif
		
		*--------------------------------------------------------
		* Create the file. File will be overwritten if it exists:
		*--------------------------------------------------------
		if not empty( m.cFile )
			curSel = select(0)
			select 0
			use (INT_REGISTRY_TABLE) alias frxreg2 Again shared
			try
				if file( m.cFile )
					erase (m.cFile)
				endif
				copy to (m.cFile) 
			catch to oErr
				=messagebox( UNABLE_TO_COPY_REGISTRY_LOC + c_CR2 + oErr.Message, 0+16, DEFAULT_MBOX_TITLE_LOC )
			endtry
			use in frxreg2
			select (m.curSel)
		endif
		
		if not m.lFileSpecified
			*--------------------------------------------------------
			* ENH for SP2: 
			* Prompt to see if you want to use this one 
			* as the current config:
			*--------------------------------------------------------
			if messagebox(USE_COPY_AS_DEFAULT_REGISTRY_LOC,4+32,DEFAULT_MBOX_TITLE_LOC) = 6	
				THIS.Execute( 3, m.cFile )
			endif
		endif
	ENDPROC

	PROCEDURE Destroy
		*=======================================================
		* Destroy()
		*  - null out any possible hanging object references
		*  - restore the data session, and close any other files
		*    that we might have opened
		*=======================================================
		
		THIS.sessionData = null
		THIS.frxCursor   = null
		
		set datasession to (this.frxSessionId)
		THIS.closeRegistry()
		
		if used('frx')
			select frx
		endif
		return
		
	ENDPROC

	PROCEDURE editxmlmetadata
		*========================================================
		* EditXmlMetadata()
		*
		* New in SP2: Allows editing of Memberdata XML
		*========================================================
		local oForm, iSelect
		iSelect = select(0)
		oForm = newobject("frxMemoEditForm","frxBuilder.vcx")
		oForm.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		oForm.setHelperText(RUNTIME_EXT_XML_HELPER_TXT_LOC)
		oForm.cmdModiComm.Visible = .T.
		oForm.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Obtain the current full metadata in XML string form:
		*------------------------------------------------------
		local lcCurrXml, lcNewXml
		
		*--------------------------------------
		* Fix for SP2: force a "reportdata" node name
		*--------------------------------------
		select * from memberdata into cursor reportdata where not deleted()
		lcCurrXml = THIS.frxCursor.CursorToXmlStr( "reportdata" )
		use in reportdata
		
		if empty(m.lcCurrXml)
			*-------------------------------------------
			* No member data currently, so 
			* use the default template in the editor:
			*-------------------------------------------
			lcCurrXml = DEFAULT_MEMBERDATA_XML
		endif
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		oForm.Text = m.lcCurrXml
		
		*------------------------------------------------------
		* m.lcXml now has a backup of the current memberdata xml
		*------------------------------------------------------
		do while .T.
		
			oForm.Execute()
			
			lcNewXml = oForm.Text
			
			if oForm.SaveChanges
				if (m.lcNewXml = m.lcCurrXml)
					*---------------------------------
					* No changes made! Don't bother saving
					*---------------------------------
					exit
				else
					if upper(m.lcNewXml) = upper(DEFAULT_MEMBERDATA_XML)
						*---------------------------------
						* Effectively back at default, so
						* empty it out so that no records
						* are created in the memberdata cursor:
						*---------------------------------
						lcNewXml = ""
					endif
					*------------------------------------------------------
					* Rebuild the memberdata cursor:
					*------------------------------------------------------
					if THIS.frxCursor.XmlStrToCursor( m.lcNewXml, "memberdata" )
						exit
					else
						*------------------------------------------------------
						* Error occurred. Throw them back into the editor:
						*------------------------------------------------------
						oForm.Text = m.lcNewXml
						loop
					endif
				endif
			else
				*------------------------------
				* We're not saving changes
				*------------------------------
				if not used("memberdata")
					if not THIS.frxCursor.XmlStrToCursor( m.lcCurrXml, "memberdata")
						*-------------------------------------
						* Now we have serious problems...
						*-------------------------------------
						* TODO: What?
					endif
				endif
				exit
			endif
		enddo
		select (m.iSelect)
		return
		
	ENDPROC

	PROCEDURE execute		&& This is the main framework logic, handling the event by looking up a handler class in the registry table, performing init code, cleanup code, etc.
		*=======================================================
		* Execute()
		*
		* This is the main framework logic, handling the event 
		* by looking up a handler class in the registry table, 
		* performing initialization code, cleanup code, etc.
		*=======================================================
		
		lparameters nSwitch, nEventType, oClauses, iDefSessionId 
		
		*------------------------------------------------------------
		* Manually calling (_REPORTBUILDER):
		*
		*    nSwitch:    1 or not passed: Show Report Builder Options dialog
		*
		*    nSwitch:    2:  Browse an FRX file
		*	 nEventType: FRX filename, or not passed - prompt for file
		*
		*    nSwitch:    3:  Set handler registry table to use
		*	 nEventType: filename of table to use as handler registry table
		*
		*    nSwitch:    4:  Sets the Handle Mode for this session
		*	 nEventType: integer representing handle mode: 1=normal, 2=debug, 3=eventinspector, 4=ignore
		*
		*    nSwitch:    5:  Copy internal registry table out to disk
		*	 nEventType: filename of table to create copy as
		*
		*    nSwitch:    6:  Add ReportBuilder Options to Tools menu
		*
		*    Added for SP1:
		*    ---------------
		*    nSwitch:    0 : Instantiate the public _oReportBuilder variable (THIS)
		*
		*    nSwitch:    7:  Launch the Event Hander Registry Explorer window
		*
		*    nSwitch:    8:  Band Object Explorer
		*    nEventType: filename of frx to explore
		*
		*------------------------------------------------------------
		do case
		case m.nSwitch = 0 		&& saves a reference to this object in a public var
			public _oReportBuilder
			_oReportBuilder = THIS
			return 0	
		
		case m.nSwitch = 1 		&& Display the options dialog
			this.showOptions()
			return 0
		
		case m.nSwitch = 2  	&& select FRX and browse
			this.browseFrx( m.nEventType )
			return 0
		
		case m.nSwitch = 3  	&& set the registry table to use for this session
			if empty( m.nEventType )
				THIS.sessionData.set("Registry","*")
			else
				this.sessionData.set("Registry", m.nEventType )
			endif
			return 0
		
		case m.nSwitch = 4		&& sets the handle mode for this session
			if vartype( m.nEventType ) = "N" 
				this.sessionData.set("handleMode", min(4,max(m.nEventType,1)) )
			endif
			return 0
		
		case m.nSwitch = 5		&& copies out the internal registry table
			this.CopyRegistry( m.nEventType )
			return 0
		
		case m.nSwitch = 6		&& Adds ReportBuilder Options to the Tools menu
			try 
				local nBar
				nBar = barcount("_mtools")+1
				define bar m.nBar of _mtools ;
					prompt UI_OPTIONS_FORM_CAPTION_LOC ;
					before _mtl_sp200 ;
					pictres _mwz_reprt ;
					message UI_TOOLSMENU_OPTIONS_MESSAGE_LOC 
				on selection bar m.nBar of _mtools do home()+"ReportBuilder.App"
			catch
				* if it doesn't work, then it doesn't work.
			endtry
			return 0	
		
		case m.nSwitch = 7		&& Registry Explorer
			this.BrowseRegistry()
			return 0
		
		case m.nSwitch = 8		&& Band Object Explorer
			this.browseBandObjects( m.nEventType )
			return 0
		
		case m.nSwitch > 8		&& unknown switch
			return 0			
		
		endcase
		
		*------------------------------------------------------------
		* At this point, we can assume its a regular builder hook call.
		* The FRX cursor MUST be available, or it's a wash.
		*------------------------------------------------------------				
		if not used('frx')
			=messagebox( RB_INVALID_PARAMETERS_LOC, 48, DEFAULT_MBOX_TITLE_LOC )
			return FRX_REPBLDR_HANDLE_EVENT + FRX_REPBLDR_DISCARD_CHANGES
		endif
		
		*------------------------------------------------------------
		* Anticipating that some people might claim that the (potential)
		* sluggishness is due to the Xbase components, let's display 
		* a WAIT WINDOW.. while the code is loading up and cleanup down:
		*------------------------------------------------------------
		if DEBUG_WAITMSG_WHILE_EXECUTING
			wait window "Builder loading..." nowait
		endif
		
		*------------------------------------------------------------
		* Save the Report Designer builder hook parameters:
		*
		*    nEventType:    integer event type code. 
		*    oClauses:      object containing clauses of "MODI REPO" command line 
		*    iDefSessionId: session id of Report Designer data session
		*------------------------------------------------------------
		this.eventType        = m.nEventType
		this.commandClauses   = m.oClauses 
		this.defaultSessionId = m.iDefSessionId
		this.protected        = m.oClauses.protected
		
		*------------------------------------------------------------
		* We are in a private datasession.
		* The temporary FRX cursor is open, selected, with alias = "frx".
		* The repord pointer is (usually) located on the current or "target"
		* object record:
		*------------------------------------------------------------
		select frx
		this.UniqueID     = frx.UNIQUEID
		this.defaultRecno = recno('frx')
		
		*------------------------------------------------------------
		* Selected objects in the layout will have CURPOS=.T. in the 
		* FRX cursor. Are we in a multi-select object situation?
		* (Note: the header record (recno()=1) may also have CURPOS=.T. 
		* if the report has "show position=Yes". 
		*------------------------------------------------------------
		this.selectedObjectCount = this.frxCursor.getSelectedObjectCount()
		
		if this.selectedObjectCount > 1 and ;
		   this.defaultRecno > 1 and ;
		   frx.CURPOS
			
			*------------------------------------------------------------
			* Multiple selected objects in the layout, and one of the 
			* selected objects is being actioned
			* 
			* Current strategy: Assuming we have a special handler class for 
			* multi-select situations, set the ObjType to OBJTYPE_MULTISELECT
			* (which doesn't actually existing as a record type in the FRX,
			* but we pretend it does for the purposes of looking for a class
			* in the handler registry table.)
			*------------------------------------------------------------
			this.ObjType  = FRX_OBJTYPE_MULTISELECT
			this.ObjCode  = 0
		
			*------------------------------------------------------------
			* For multi-select, ensure we're on the header record:
			* (used to distinguish between groups and multi-select)
			*------------------------------------------------------------
			go top
			
		else
			*------------------------------------------------------------
			* Use the current record pointer as indicating the target 
			* object:
			*------------------------------------------------------------
			this.ObjType  = frx.OBJTYPE
			this.ObjCode  = frx.OBJCODE
		endif		
		
		*------------------------------------------------------------
		* At one point we needed to buffer changes to the FRX cursor
		* ourselves, but now the Designer only reloads the FRX cursor 
		* if we tell it to:
		*------------------------------------------------------------
		if BUILDER_USES_TABLE_BUFFERING
			set multilocks on            && scoped to session
			cursorsetprop("Buffering",4) && better than 5 for performance?
		endif
		
		*------------------------------------------------------------
		* Has the Handler Mode override been set to something other
		* than "use handler registry table"?
		*------------------------------------------------------------
		this.handleMode = this.sessionData.get("handleMode")
		
		*------------------------------------------------------------
		* Open the handler registry table:
		*------------------------------------------------------------
		this.openRegistry()
		
		*------------------------------------------------------------
		* Respect handle mode override, if set:
		*------------------------------------------------------------
		do case
		case THIS.handleMode = MODE_FORCE_NATIVE
			*------------------------------------------------------------
			* Native means pass all events back to the Designer for 
			* "normal" behaviour:
			*------------------------------------------------------------
			return FRX_REPBLDR_IGNORE_EVENT + FRX_REPBLDR_DISCARD_CHANGES
			
		case THIS.handleMode	= MODE_FORCE_MSBOX
			*------------------------------------------------------------
			* "Event Inspector" displays the incoming event details 
			* in a messagebox window. Filters do not run.
			*------------------------------------------------------------
		
		
		case THIS.handleMode	= MODE_FORCE_DEBUG
			*------------------------------------------------------------
			* "Debug mode" brings up the FRX browser/event debugger.
			* Filters do not run.
			*------------------------------------------------------------
		
		otherwise
			*------------------------------------------------------------
			* Regular event processing: Check for Filters:
			*------------------------------------------------------------
			*------------------------------------------------------------
			* Filters are special handler classes that, if registered, get 
			* a chance to perform up-front processing, and optionally "eat" 
			* the event off the queue, or even throw it back to the 
			* Designer for regular, native behaviour.
			* A typical example would be selected protection flags, where, 
			* if set, it is good to terminate and return processing to the 
			* designer as quickly as possible.
			*------------------------------------------------------------
			if this.processedByFilter()
			
				THIS.closeRegistry()
		
				*------------------------------------------------------
				* This used to be forced on but it is better to respect
				* the fact that any of the filter classes could have 
				* set the return flags the way they wanted to:
				*------------------------------------------------------
				* THIS.setHandledByBuilder(.T.)
		
				return THIS.returnFlags
			endif
		
		endcase
		
		*------------------------------------------------------------
		* Now look for a class to handle the event, and execute it:
		*------------------------------------------------------------
		if not THIS.Handle()
			*------------------------------------------------------------
			* An appropriate handler class was not found.
			*
			* NOTE: an argument could be made that the exitHandlers should
			*       be processed in this case, rather than exiting early
			*------------------------------------------------------------
			return THIS.returnFlags
		endif
		
		*------------------------------------------------------------
		* Each registered "exit" handler gets a chance to post-process
		* the event:
		*------------------------------------------------------------
		THIS.processExitHandlers()
		
		*------------------------------------------------------------
		* Now we can close the registry:
		*------------------------------------------------------------
		THIS.closeRegistry()
		
		*------------------------------------------------------------
		* At one point we needed to buffer changes to the FRX cursor
		* ourselves, but now the Designer only reloads the FRX cursor 
		* if we tell it to:
		*------------------------------------------------------------
		if BUILDER_USES_TABLE_BUFFERING
			if bittest( m.rnRetVal, FRX_REPBLDR_HANDLE_EVENT )
				*------------------------------------------------------------
				* the builder has requested that changes be reloaded:
				* so flush the buffer:
				*------------------------------------------------------------
				select frx
				=tableupdate(1) && save all rows
			endif
		endif
		
		*------------------------------------------------------------
		* The handler objects will have set this appropriately:
		*------------------------------------------------------------
		return this.returnFlags 
		
	ENDPROC

	PROCEDURE geteventtypetext		&& Returns a readable string value version of an event type.
		*=======================================================
		* GetEventTypeText( [ eventType ] ) 
		*
		* Returns a readable string value version of an event Type
		*=======================================================
		lparameters nEventType
		
		if parameters() = 0
			nEventType = THIS.eventType
		endif
		
		do case
		case m.nEventType = FRX_BLDR_EVENT_RIGHTCLICK
			return EVTYP_RIGHTCLICK_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_PROPERTIES
			return EVTYP_PROPERTIES_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_OBJECTCREATE
			return EVTYP_OBJECT_CREATE_LOC
			
		*case m.nEventType = FRX_BLDR_EVENT_OBJECTCHANGE
		*	return EVTYP_OBJECT_CHANGE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_OBJECTREMOVE
			return EVTYP_OBJECT_REMOVE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_OBJECTPASTE
			return EVTYP_OBJECT_PASTE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_REPORTSAVE
			return EVTYP_REPORT_SAVE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_REPORTOPEN
			return EVTYP_REPORT_OPEN_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_REPORTCLOSE
			return EVTYP_REPORT_CLOSE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_DATAENV  
			return EVTYP_DATAENV_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_PREVIEWMODE
			return EVTYP_PRINT_PREVIEW_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_OPTIONALBANDS
			return EVTYP_OPTIONAL_BANDS_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_DATAGROUPING
			return EVTYP_DATA_GROUPING_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_VARIABLES
			return EVTYP_VARIABLES_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_EDITINPLACE
			return EVTYP_EDIT_IN_PLACE_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_OBJECTDROP
			return EVTYP_OBJECT_DROP_LOC
		
		case m.nEventType = FRX_BLDR_EVENT_SETGRIDSCALE
			return EVTYP_SET_GRID_SCALE_LOC
		
		case m.nEventType = FRX_BLDR_EVENT_IMPORTDE
			return EVTYP_IMPORT_DE_LOC
		
		case m.nEventType = FRX_BLDR_EVENT_PRINT
			return EVTYP_PRINT_LOC
			
		case m.nEventType = FRX_BLDR_EVENT_QUICKREPORT
			return EVTYP_QUICKREPORT_LOC
		
		otherwise
			return EVTYP_UNKNOWN_LOC
		
		endcase	
		
	ENDPROC

	PROCEDURE getexpression		&& Displays a GETEXPR dialog and returns a string containing the entered expression. Developers can replace the default GETEXPR wrapper with their own implementation, registered in the handler table.
		*=======================================================
		* GetExpression( cDefaultExpr, cDataType, cCalledFrom )
		*
		* Displays a getExpr dialog and returns a string containing
		* the expression.
		*=======================================================
		lparameter lcDefaultExpr, lcDataType, lcCalledFrom
		
		local curSel, cClass, cLibrary, cRegistry, oGetExpr
		
		*-------------------------------------------------------
		* Look for a GetExpression wrapper in the registry:
		*-------------------------------------------------------
		curSel = select(0)
		select frxRegistry
		cRegistry = dbf()
		locate for REC_TYPE = HANDLREG_GETEXPR and not deleted()
		if found()
			cClass   = trim(HNDL_CLASS)
			cLibrary = trim(HNDL_LIB)
		else
			cClass   = "GetExprWrapper"
			cLibrary = HANDLERS_PRG_CLASSLIB
		endif
		select (m.curSel)
		
		*-------------------------------------------------------
		* Move into the designer's data session:
		*-------------------------------------------------------
		set datasession to (THIS.defaultSessionId)
		
		*-------------------------------------------------------
		* instantiate the class:
		*-------------------------------------------------------
		*----------------------------------------------------
		* New in SP1: Look in specific locations for classlib
		*----------------------------------------------------
		oGetExpr = THIS.NewRegisteredObject( m.cClass, m.cLibrary )
		
		*-------------------------------------------------------
		* Get it to prompt for the expression:
		*-------------------------------------------------------
		local cRetVal
		if not isnull( m.oGetExpr )
			cRetVal = oGetExpr.GetExpression( m.lcDefaultExpr, m.lcDataType, m.lcCalledFrom, THIS )
		else
			=messagebox( RB_GETEXPR_FAILURE_LOC, 0+16, DEFAULT_MBOX_TITLE_LOC )
			cRetVal = inputbox( RB_DEF_GETEXPR_PROMPT_LOC, DEFAULT_MBOX_TITLE_LOC, m.lcDefaultExpr )
		endif
		
		*-------------------------------------------------------
		* Restore the data session:
		*-------------------------------------------------------
		set datasession to (THIS.frxSessionId)
		
		return m.cRetVal
	ENDPROC

	PROCEDURE getextensioneditor		&& returns a reference to an instance of the class defined in the reportbuilder handler registry as the Run-time extensions editor class.
		*=======================================================
		* GetExtensionEditor()                       
		*=======================================================
		return THIS.GetRegisteredObject( ;
						HANDLREG_RTEXTEND, ;
						"frxRuntimeEditor", ;
						"frxBuilder.vcx" )
	ENDPROC

	PROCEDURE getfrxbrowser
	ENDPROC

	PROCEDURE gethandlerregistryeditor
	ENDPROC

	PROCEDURE getlibraryappname
		*=======================================================
		* GetLibraryAppName()
		*
		* returns the application file name (EXE or APP file name) 
		* for the given class library if it can be found.
		*
		* It is required to properly load class libraries packaged in 
		* APPs or EXEs.
		* 
		*=======================================================
		*-------------------------------------
		* For SP2 (re Sharov Taras):
		*-------------------------------------
		lparameter lcLibrary
		
		lcLibrary = upper(m.lcLibrary)
		
		local lcLibsLoaded , lcAppFile
		lcAppFile    = ""
		lcLibsLoaded = set("CLASSLIB")
		
		if m.lcLibrary $ m.lcLibsLoaded
			lcAppFile = alltrim(substr( m.lcLibsLoaded, at( m.lcLibrary, m.lcLibsLoaded ) + len( m.lcLibrary )))
			if left( m.lcAppFile, 3 ) == "IN "	
				lcAppFile = alltrim(substr( m.lcAppFile, 4 ))
				do case
				case ".APP" $ m.lcAppFile
					lcAppFile = alltrim(substr( m.lcAppFile, 1, at( ".APP", m.lcAppFile)+3 ))
					
				case ".EXE" $ m.lcAppFile
					lcAppFile = alltrim(substr( m.lcAppFile, 1, at( ".EXE", m.lcAppFile)+3 ))
		
				endcase
				if not file( m.lcAppFile )
					lcAppFile = ""
				endif		
			else
				lcAppFile = ""
			endif
		endif
		return m.lcAppFile
		
	ENDPROC

	PROCEDURE getlibraryfilename		&& returns the fully qualified file name of the specified partial class library file name. Parameter: cLibrary  (e.g. "plugins\mylib.prg")
		*=======================================================
		* GetLibraryFileName()
		*
		* returns the fully qualified file name of the given partial filename.
		* Searches path, builder path.
		*=======================================================
		lparameter lcFile
		
		do case
		case file( m.lcFile )
			*--------------------------------------------------------
			* ok to continue, it's valid.
			*--------------------------------------------------------
			
		case file( fullpath( m.lcFile ))
			*--------------------------------------------------------
			* found on path, so use this one
			*--------------------------------------------------------
			lcFile = lower(fullpath(m.lcFile))
			
		case file( this.builderPath + m.lcFile ) 
			*--------------------------------------------------------
			* found in the builder.app path/HOME()
			*--------------------------------------------------------
			lcFile = this.builderPath + m.lcFile
			
		endcase
		return m.lcFile
		
	ENDPROC

	PROTECTED PROCEDURE getmemoryback		&& This switches into the default data session and checks to see if it can get hold of a reference to one created earlier. Stores a name-value pair collection as a property of _screen.
		*=======================================================
		* GetMemoryBack()                              PROTECTED
		*
		* This switches into the default data session and checks
		* to see if we can get hold of a reference to "one we created 
		* earlier". We store our name-value pair collection as a 
		* property of _screen. 
		* (Yeah, it could have been a public variable. Is this 
		* any better? Maybe. Still won't survive CLEAR ALL)
		*=======================================================
		if type( "_screen.reportbuilderdata" ) = "U"
			_screen.AddProperty("reportbuilderdata")
		endif
		if type( "_screen.reportbuilderdata" ) <> "O" or ;
		   isnull( _screen.reportbuilderdata )
		   
			*-------------------------------------------------------
			* Create the object in the default data session to avoid
			* hanging data sessions:
			*-------------------------------------------------------
			set datasession to 1
			
		   	*-------------------------------------------------------
			* Create the object:
			*-------------------------------------------------------
			_screen.reportbuilderdata  =  newobject("NameValuePairManager", FRXCOMMON_PRG_CLASSLIB ) 
			
			*-------------------------------------------------------
			* The default handle mode is 1 - use handler registry table:
			*-------------------------------------------------------
			_screen.reportbuilderdata.Set("handleMode",1)			&& use registry
			
			set datasession to (THIS.frxSessionId)
		endif
		
		return _screen.reportbuilderdata
		
	ENDPROC

	PROCEDURE getregisteredobject		&& Parameters: cRecType [, cDefaultClass, cDefaultLib ]
		*============================================================
		* GetRegisteredObject()
		*
		* Developers can replace the default classes in the registry
		* with their own implementations. This method pulls the 
		* requested type of class from the registry and instantiates it.
		*
		* Assumes: registry is open under alias "frxregistry"
		*============================================================
		lparameters lcClassType, lcDefaultClass, lcDefaultLib
		
		local cursel, retval, cClass, cLibrary
		cursel = select(0)
		retval = .NULL.
		
		select frxRegistry
		
		if THIS.LocateExtensionClass( lcClassType )
			cClass   = trim(frxregistry.HNDL_CLASS)
			cLibrary = trim(frxregistry.HNDL_LIB)
		else
			if pcount() = 3
				cClass   =	m.lcDefaultClass
				cLibrary =  m.lcDefaultLib
			else
				select (m.cursel)
				return .NULL.
			endif
		endif
		
		*--------------------------------------------------------
		* Return the class instance:
		*--------------------------------------------------------
		*----------------------------------------------------
		* New in SP1: Look in a specific sequence of locations 
		*             for the classlib, using a new method:
		*----------------------------------------------------
		retVal = THIS.NewRegisteredObject( m.cClass, m.cLibrary )
		
		select (m.cursel)
		return m.retval
	ENDPROC

	PROCEDURE getregistrytablename		&& Returns the fully qualified file name of the registry table.
		*=======================================================
		* GetRegistryTableName()
		*
		* returns the fully qualified file name of the registry 
		* table. Could be a number of places to get it from.
		*=======================================================
		*-------------------------------------------------------
		* Enh for SP2: Defer to the utils opject: 
		*              uses slightly improved search algorithm
		*              that allows for a setting in CONFIG.FPW,
		*              among other things
		*-------------------------------------------------------
		local cFile
		cFile = THIS.setupUtils.GetBuilderRegistryTableName()
		THIS.usingInternalRegistry = THIS.setupUtils.usingInternalRegistry
		return m.cFile
		
		
	ENDPROC

	PROCEDURE gettargettypetext		&& Returns a readable string value version of an ObjectType+Code combination.
		*=======================================================
		* GetTargetTypeText( [ OBJTYPE, OBJCODE ] )
		*
		* Returns a readable string value version of an Object 
		* Type+Code combination. 
		* Calls frxCursor::getTargetTypeText()
		*=======================================================
		lparameters  nObjType, nObjCode
		
		if parameters() = 0
			nObjType = THIS.objType
			nObjCode = THIS.objCode
		endif
		
		return THIS.frxCursor.getTargetTypeText( m.nObjType, m.nObjCode )
		
		
	ENDPROC

	PROCEDURE handle		&& This method handles the event by looking up a handler class in the registry table, and executing it. Assumes: the registry table is open (alias "frxregistry")
		*=======================================================
		* Handle()
		*
		* This method handles the event by looking up a handler 
		* class in the registry table, and executing it.
		* Assumes:
		* - registry is open (alias frxRegistry)
		* - frx table is open and located on the correct record?
		* - event type is given by THIS.eventType
		*=======================================================
		lparameters iObjType, iObjCode
		
		local liOType, liOCode, llContinue
		store .T. to llContinue
		store 0   to liOType, liOCode
		
		if parameters() = 2
			*------------------------------------------------------------
			* Back up the current values:
			*------------------------------------------------------------
			liOType = THIS.ObjType
			liOCode = THIS.ObjCode
			*------------------------------------------------------------
			* Switch to the passed values:
			*------------------------------------------------------------
			THIS.ObjType = m.iObjType
			THIS.ObjCode = m.iObjCode
		else
			*------------------------------------------------------------
			* Use the values as already determined in the .Execute() method:
			*------------------------------------------------------------
			iObjType = THIS.ObjType
			iObjCode = THIS.ObjCode
		endif
		
		*------------------------------------------------------------
		* Respect specific handle mode overrides, if set:
		*------------------------------------------------------------
		local cHandlerClass, cHandlerLib
		do case 
		case THIS.handleMode = MODE_FORCE_MSBOX
			*------------------------------------------------------------
			* The Event Inspector is just a messagebox that pops up in 
			* front of all events, with a list of the incoming parameters,
			* and how the builder has identified the event:
			*------------------------------------------------------------
			cHandlerClass = "EventHookAlert"
			cHandlerLib   = HANDLERS_PRG_CLASSLIB 
		
		case THIS.handleMode = MODE_FORCE_DEBUG
			*------------------------------------------------------------
			* Force Debug means use the special "debug browse mode" 
			* user interface. Only practical for debugging, and not so 
			* useful now we've added "browse FRX" to the right-click menu
			* on the regular handler forms...
			*------------------------------------------------------------
			cHandlerClass = "debugHandler"
			cHandlerLib   = BUILDER_CLASSLIB
		
		otherwise		
		
			*------------------------------------------------------------
			* Now look for an appropriate specific handler registered to 
			* this event, or class of events:
			*------------------------------------------------------------
			this.locateHandlerClass( THIS.eventType, m.iObjType, m.iObjCode )
		
			do case
			case not found('frxRegistry')
				*------------------------------------------------------------
				* The event doesn't appear to be registered to anything,
				* and there is no catch-all handler defined:
				* do not handle the event:
				*------------------------------------------------------------
				THIS.setHandledByBuilder(.F.)
				llContinue = .F.
		
			case frxregistry.NATIVE
				*------------------------------------------------------------
				* There was a match, but it has been configured to
				* drop through to native behaviour:
				*------------------------------------------------------------
				THIS.setHandledByBuilder(.F.)
				llContinue = .F.
		
			case frxregistry.DEBUG
				*------------------------------------------------------------
				* There was a match, but it has been configured to
				* use the debug handler:
				*------------------------------------------------------------
				cHandlerClass = "debugHandler"
				cHandlerLib   = BUILDER_CLASSLIB
				
			otherwise
				*------------------------------------------------------------
				* We have a match:
				*------------------------------------------------------------
				cHandlerClass = trim( frxregistry.HNDL_CLASS ) 
				cHandlerLib   = trim( frxregistry.HNDL_LIB )
		
			endcase
		
		endcase
		
		if m.llContinue
			*------------------------------------------------------------
			* Make sure the FRX is selected going in to the Handler code:
			*------------------------------------------------------------
			select frx
		
			*------------------------------------------------------------
			* Create the handler object and pass the handler object a 
			* reference to the event object to process:
			*------------------------------------------------------------
		
			*----------------------------------------------------
			* New in SP1: Look in specific locations for classlib
			*----------------------------------------------------
			oHandler = THIS.NewRegisteredObject( m.cHandlerClass, m.cHandlerLib )
			if not isnull( oHandler )
				*----------------------------------------------------
				* Enhanced for SP1:
				* Check that the API is supported:
				*----------------------------------------------------
				if pemstatus( oHandler, "Execute", 5 )
					oHandler.Execute( THIS )
				else
					=messagebox( strtran(RB_ERROR_API_NOT_SUPPORTED_LOC,"{0}",oHandler.Class);
							+chr(13)+RB_ERROR_CHECK_REGISTRY_LOC, 16, DEFAULT_MBOX_TITLE_LOC  )
				endif
			endif
		
		endif
		
		if m.liOType > 0
			*------------------------------------------------------------
			* Restore the original values:
			*------------------------------------------------------------
			THIS.ObjType = m.liOType
			THIS.ObjCode = m.liOCode
		endif
		
		return .T.
		
	ENDPROC

	PROCEDURE Init
		*=======================================================
		* Init()
		*=======================================================
		
		*------------------------------------
		* New in SP2:
		*------------------------------------
		THIS.setupUtils     = newobject("frxSetupUtils","frxsetup.prg")
		THIS.builderPath    = THIS.setupUtils.GetApplicationPath()
				
		*------------------------------------
		* New in SP2:
		*------------------------------------
		*THIS.AdvancedProperties = newobject("frxAdvProperties","frxutils.prg")
		
		*-------------------------------------------------------
		* Save the current data session for future reference:
		*-------------------------------------------------------
		THIS.frxSessionId	= set("DATASESSION")
			
		*-------------------------------------------------------
		* Create (or obtain a reference to) the session-persistent 
		* name-value pair collection:
		*-------------------------------------------------------
		THIS.sessionData	= THIS.getMemoryBack()
		
		*-------------------------------------------------------
		* Create our helper/utility object for interacting with
		* the FRX cursor:
		*-------------------------------------------------------
		THIS.frxCursor     = newobject("frxCursor","_frxCursor.vcx")
		
		*------------------------------------
		* Fixed for SP1: 
		* Reset .screenDPI to 96 so that it
		* is correct for design-time report designer use.
		*------------------------------------
		THIS.frxCursor.ScreenDPI = 96
				
		THIS.unitConverter = newobject("frxUnitConverter", "frxBuilder.vcx")
		
		*-------------------------------------------------------
		* Fix for SP2: 
		* Kludge: Initialise the .usingInternalRegistry flag:
		*-------------------------------------------------------
		THIS.GetRegistryTableName()
		
		*-------------------------------------------------------
		* We do create/delete files, and this is a data-session
		* -specific property, so it's safe to do here:
		*-------------------------------------------------------
		set Safety off
		
		return
	ENDPROC

	PROCEDURE locateextensionclass
		*=======================================================
		* LocateExtensionClass()                       PROTECTED
		*
		* Searches the handler registry table for a class registered
		* to a specific type
		*
		* Assumes:
		* - registry table is open with alias of 'frxregistry'
		*=======================================================
		lparameters cType
		
		local curSel
		curSel = select(0)
		
		select frxRegistry
		locate for REC_TYPE = m.cType and not deleted()
		
		select (curSel)
		
		*-------------------------------------------------------
		* registry table will be located on the found() record:
		*-------------------------------------------------------
		
		return found('frxRegistry')	
		
	ENDPROC

	PROTECTED PROCEDURE locatehandlerclass		&& Searches the handler registry table for a handler class that is registered to a specific combination of event type and target object, using progressively less selective search criteria in an attempt to get a match. Assumes: registry table is open.
		*=======================================================
		* LocateHandlerClass()                         PROTECTED
		*
		* Searches the handler registry table for a handler class
		* that is registered to the specific combination of event
		* type and target object, using progressively less selective
		* searches in an attempt to get a match.
		* Assumes:
		* - registry table is open 
		*=======================================================
		lparameters iEvent, iObjType, iObjCode
		
		select frxRegistry
		
		do while .t.
			*-------------------------------------------------------
			* look for a class specific to the event-target:
			*-------------------------------------------------------
			locate for EVENTTYPE = m.iEvent ;
			       and OBJTYPE   = m.iObjType ;
				   and OBJCODE   = m.iObjCode ;
				   and REC_TYPE  = HANDLREG_HANDLER  ;
				   and not deleted()
		
			if found()
				exit
			endif
		
			*-------------------------------------------------------
			* Fix for SP2:
			* look for a class specific to the event-target, 
			* any layout control, if it is a layout control:
			*-------------------------------------------------------
			if this.frxCursor.IsLayoutControl( frx.OBJTYPE )
				locate for EVENTTYPE = m.iEvent ;
			   		    and OBJTYPE  = FRX_OBJTYPE_LAYOUTCONTROLS ;
					    and OBJCODE  = -1 ;
					   and REC_TYPE  = HANDLREG_HANDLER  ;
					   and not deleted()
		
				if found()
					exit
				endif
			endif
			
			*-------------------------------------------------------
			* look for a class specific to the event-target, any code:
			*-------------------------------------------------------
			locate for EVENTTYPE = m.iEvent ;
		   		    and OBJTYPE  = m.iObjType ;
				    and OBJCODE  = -1 ;
				   and REC_TYPE  = HANDLREG_HANDLER  ;
				   and not deleted()
		
			if found()
				exit
			endif
			
			*-------------------------------------------------------
			* look for a class specific to the event, any target:
			*-------------------------------------------------------
			locate for EVENTTYPE = m.iEvent ;
		   		    and OBJTYPE = -1 ;
				    and OBJCODE = -1 ;
				   and REC_TYPE  = HANDLREG_HANDLER  ;
				   and not deleted()
		
			if found()
				exit
			endif
			
			*-------------------------------------------------------
			* look for a class defined as a generic catch-all:
			*-------------------------------------------------------
			locate for EVENTTYPE = -1 ;
		   		    and OBJTYPE = -1 ;
				    and OBJCODE = -1 ;
				   and REC_TYPE  = HANDLREG_HANDLER  ;
				   and not deleted()
			exit
		enddo
		*-------------------------------------------------------
		* registry table will be located on the found() record:
		*-------------------------------------------------------
		select frx
		return found('frxRegistry')	
		
	ENDPROC

	PROCEDURE multiselect_access
		return this.selectedObjectCount > 1
	ENDPROC

	PROCEDURE newregisteredobject
		*=======================================================
		* NewRegisteredObject( class, library )
		*
		* This method instantiates a class using NEWOBJECT().
		* It uses a hierarchy of search paths in an attempt to ensure
		* that the class library is found.
		* Class/Library search order:
		*   looks in CLASSPATH
		*   looks relative to current directory
		*   looks relative to directory of current registry table
		*   looks relative to directory of ReportBuilder.App
		*   then fails
		* If a class can not be instantiated, NULL is returned.
		*-------------------------------------------------------
		* New in SP1
		*=======================================================
		lparameters tcClass, tcLibrary
		local oInstance, lSuccess
		
		*-------------------------------------
		* For SP2:
		*-------------------------------------
		tcClass   = alltrim( m.tcClass )
		tcLibrary = alltrim( m.tcLibrary )
		
		try
			lCreated = .T.
			if empty( m.tcLibrary )
				*---------------------------------
				* Try the CLASSPATH:
				*---------------------------------
				oInstance = newobject( m.tcClass )
			else
				*---------------------------------
				* Try normal relative path:
				*---------------------------------
				*-------------------------------------
				* For SP2 (re Sharov Taras):
				*-------------------------------------
				local lcApplication
				if not empty( m.tcLibrary )
					lcApplication = this.GetLibraryAppName( m.tcLibrary )
				else
					lcApplication = ""
				endif
		
				oInstance = newobject( m.tcClass, m.tcLibrary, m.lcApplication )
			endif
		catch
			lCreated = .F.
			oInstance = .NULL.
		endtry	
		if m.lCreated
			return m.oInstance
		endif
		
		*---------------------------------
		* Try relative to registry dbf:
		*---------------------------------
		try
			lCreated = .T.
			oInstance = newobject( m.tcClass, addbs(justpath(THIS.GetRegistryTableName())) + m.tcLibrary )
		catch
			lCreated = .F.
			oInstance = .NULL.
		endtry	
		if m.lCreated
			return m.oInstance
		endif
		
		*---------------------------------
		* Try relative to the main app/exe:
		*---------------------------------
		try
			lCreated = .T.
			oInstance = newobject( m.tcClass, THIS.BuilderPath + m.tcLibrary )
		catch
			lCreated = .F.
			oInstance = .NULL.
		endtry	
		if m.lCreated
			return m.oInstance
		endif
		
		*---------------------------------
		* Try relative to HOME(0)
		*---------------------------------
		try
			lCreated = .T.
			oInstance = newobject( m.tcClass, addbs(justpath(home(0))) + m.tcLibrary )
		catch
			lCreated = .F.
			oInstance = .NULL.
		endtry	
		
		if m.lCreated
			return m.oInstance
		endif
		
		if not m.lCreated
			=messagebox( ;
				RB_ERROR_NEWOBJECT_LOC                                          + c_CR2 + ;
				UI_NEWREGOBJ_CLASS_LOC  + "   "   + m.tcClass                   + c_CR  + ;
				UI_NEWREGOBJ_LIBRARY_LOC  + " "   + m.tcLibrary                 + c_CR  + ;
				UI_NEWREGOBJ_REGTABLE_LOC + " "   + THIS.GetRegistryTableName() + c_CR2 + ;
				RB_ERROR_CHECK_REGISTRY_LOC, 0+16, DEFAULT_MBOX_TITLE_LOC )
		endif
		return m.oInstance
		
	ENDPROC

	PROCEDURE openregistry		&& Opens the registry table.
		*=======================================================
		* OpenRegistry()
		*
		* Opens the registry table - could be default, could be
		* external in the path, could be specified manually.
		*=======================================================
		*-------------------------------------------------------
		* Enhancement for SP1
		* Allow specification of alias of registry table
		*-------------------------------------------------------
		lparameters tcAliasToUse
		if vartype(m.tcAliasToUse) <>  "C" or empty( m.tcAliasToUse ) or used(m.tcAliasToUse)
			tcAliasToUse = "frxregistry"
		endif		
		
		local cFile
		cFile = THIS.getRegistryTableName()
		select 0
		if THIS.usingInternalRegistry
			*--------------------------------------------------------
			* use readonly if it's the internal one:
			*--------------------------------------------------------
			use (m.cFile) again noupdate shared alias (m.tcAliasToUse) && frxregistry
		else
			try 
				use (m.cFile) again shared alias (m.tcAliasToUse) && frxregistry
			catch 			
				*--------------------------------------------------------
				* If the specified table doesn't exist, use the internal one:
				* This seems like the best strategy...
				* Alternatively, could bail with invalid config...
				*--------------------------------------------------------
				=messagebox( strtran(USE_REG_ERR_MBOX_MSG_LOC,"{%1}", m.cFile), 0+48, DEFAULT_MBOX_TITLE_LOC )
		
				cFile = addbs(justpath( THIS.Classlibrary )) + INT_REGISTRY_TABLE
				use (m.cFile) again noupdate shared alias (m.tcAliasToUse) && frxregistry
			endtry
		endif		
		return .T.
	ENDPROC

	PROTECTED PROCEDURE processedbyfilter		&& Processes any event filters and returns .T. if the event has been handled.
		*=======================================================
		* ProcessedByFilter()                          PROTECTED
		*
		* Process any event filters and return if the event has 
		* been filtered/handled.
		*=======================================================
		local lHaltProcessing, oFilter, lcLibrary, currRec
		lHaltProcessing = .F.
		currRec = recno('frx')
		
		*-------------------------------------------------------
		* Obtain a list of registered filter classes:
		*-------------------------------------------------------
		select * ;
			from frxRegistry ;
			where REC_TYPE = HANDLREG_FILTER ;
			  and not deleted() ;
			order by FLTR_ORDR ;
			into cursor filters
		
		*-------------------------------------------------------
		* Each one gets a chance to handle the event and stop
		* further processing:
		*-------------------------------------------------------
		scan 
			oFilter = null
		
			lcLibrary = trim( HNDL_LIB )
		
			*----------------------------------------------------
			* New in SP1: Look in specific locations for classlib
			*----------------------------------------------------
			oFilter = THIS.NewRegisteredObject( trim( HNDL_CLASS ), m.lcLibrary )
		
			select frx
			if not isnull( m.oFilter ) 
		
				*----------------------------------------------------
				* Enhanced for SP1:
				* Check that the API is supported:
				*----------------------------------------------------
				if pemstatus( oFilter, "Execute", 5 ) and pemstatus( oFilter, "allowToContinue", 5 )
					oFilter.Execute( THIS )
					if not oFilter.allowToContinue
						lHaltProcessing = .T.
						exit
					endif
				else
					=messagebox( strtran(RB_ERROR_API_NOT_SUPPORTED_LOC,"{0}", oFilter.Class );
							+chr(13)+RB_ERROR_CHECK_REGISTRY_LOC, 16, DEFAULT_MBOX_TITLE_LOC  )
				endif
			
			endif
			select filters
		endscan
		use in filters
		go m.currRec in frx
		select frxRegistry
		
		return m.lHaltProcessing
		
	ENDPROC

	PROTECTED PROCEDURE processexithandlers		&& Processes any exit handlers registered in the handler table.
		*=======================================================
		* ProcessExitHandler()                         PROTECTED
		*
		* Process any Exit Handlers
		*=======================================================
		local oHandler, cLibrary
		
		*-------------------------------------------------------
		* Obtain a list of registered ExitHandler classes:
		*-------------------------------------------------------
		select * ;
			from frxRegistry ;
			where REC_TYPE = HANDLREG_EXIT ;
			  and not deleted() ;
			order by FLTR_ORDR ;
			into cursor exits
		
		*-------------------------------------------------------
		* Each one gets a chance to perforn additional post-processing
		* on the event. Probably not a good idea to mess with 
		* THIS.returnFlags though...
		*-------------------------------------------------------
		scan
			oHandler = null
			cLibrary = trim( HNDL_LIB )
		
			*----------------------------------------------------
			* New in SP1: Look in specific locations for classlib
			*----------------------------------------------------
			oHandler = THIS.NewRegisteredObject( trim( HNDL_CLASS ), m.cLibrary )
			
			select frx
			if not isnull( m.oHandler )
				*----------------------------------------------------
				* Enhanced for SP1:
				* Check that the API is supported:
				*----------------------------------------------------
				if pemstatus( oHandler, "Execute", 5 )
					oHandler.Execute( THIS )
				else
					=messagebox( strtran(RB_ERROR_API_NOT_SUPPORTED_LOC,"{0}",oHandler.Class);
							+chr(13)+RB_ERROR_CHECK_REGISTRY_LOC, 16, DEFAULT_MBOX_TITLE_LOC  )
				endif
			endif
			select exits
		endscan
		use in exits
		select frxRegistry
		return 
		
	ENDPROC

	PROCEDURE sethandledbybuilder		&& Pass .T. to prevent the Report Designer from responding to the event with its default behavior.
		lparameter lNoDefault
		
		if m.lNoDefault
			THIS.returnFlags = bitset( THIS.returnFlags , FLAG_NODEFAULT )
		else
			THIS.returnFlags = bitclear( THIS.returnFlags , FLAG_NODEFAULT )
		endif
		return
	ENDPROC

	PROCEDURE setreloadchanges		&& Pass .T. to instruct the Report Designer to respect changes made to the FRX cursor.
		lparameter lReloadFrx
		
		if m.lReloadFrx
			THIS.returnFlags = bitset( THIS.returnFlags , FLAG_RELOAD_FRX )
		else
			THIS.returnFlags = bitclear( THIS.returnFlags , FLAG_RELOAD_FRX  )
		endif
		return
	ENDPROC

	PROCEDURE showoptions		&& Displays the Report Builder options dialog.
		*=======================================================
		* ShowOptions()
		*
		* Displays the Report Builder Options dialog.
		*=======================================================
		local oOptions
		oOptions = newobject( "frxOptions", BUILDER_CLASSLIB )
		oOptions.Execute( this )
		return
		
	ENDPROC

	PROCEDURE tostring		&& Returns a string representation of the event properties.
		*=======================================================
		* ToString()
		*
		* Returns a string representation of the event properties.
		*=======================================================
		local cText
		cText = ""
		
		cText = m.cText + "Builder Event:  " + upper(this.getEventTypeText()) + " (" + trans(this.eventType) + ")" + chr(13)
		cText = m.cText + "Applied to:     " + upper(this.frxCursor.getTargetTypeText(THIS.objType, THIS.objCode)) + " (" + trans(this.objType) + ", " + trans(this.objCode) + ")" + chr(13)
		cText = m.cText + "Current recno:  " + trans( this.defaultRecno ) + chr(13)
		cText = m.cText + trans( this.selectedObjectCount ) + " objects selected in layout." + chr(13)
		cText = m.cText + "Command clauses:" + chr(13)
		
		amembers( ac, this.commandClauses )
		for each cField in ac
			cText = m.cText + "  " + m.cField+ " = " + trans(eval("this.commandClauses."+trim(m.cField))) + chr(13)
		endfor
		
		cText = m.cText + "Current data session  = " + trans( this.frxSessionId ) + chr(13)
		cText = m.cText + "Designer data session = " + trans( this.defaultSessionId )
		
		return m.cText
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxformatutil AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: backcolor_access
		*m: backstyle_access
		*m: chartostyleflags
		*m: choosefont
		*m: fontmetric		&& Parameter: iMetricIndex. Returns the fontmetric for the current internal font.
		*m: fontstrikethru_access
		*m: fontstrikethru_assign
		*m: fontunderline_access
		*m: fontunderline_assign
		*m: forecolor_access
		*m: getbackcolor
		*m: getfontstring
		*m: getforecolor
		*m: isfontbold
		*m: isfontitalic
		*m: setbackcolor
		*m: setfont		&& parameters: cFontString ( from getFont())     Sets the internal properties ...
		*m: setforecolor
		*m: styleflagstochar
		*m: transparency_assign
		*m: txtwidth		&& Wraps TXTWIDTH() to yield the result with respect to the current font. Parameter: cString
		*p: alphafill
		*p: alphapen
		*p: backcolor		&& Specifies the background color used to display text and graphics in an object.
		*p: backstyle		&& Specifies if the background of an object is transparent or opaque.
		*p: defaultbackcolor
		*p: defaultforecolor
		*p: fontcharset		&& Specifies the script for the font used to display text.
		*p: fontface
		*p: fontsize		&& Specifies the font size for text displayed with an object.
		*p: fontstrikethru		&& Specifies if the text is strikethru.
		*p: fontstyle		&& Specifies the style of a control.
		*p: fontunderline		&& Specifies if the text is underlined.
		*p: forecolor		&& Specifies the foreground color used to display text and graphics in an object.
		*p: frxcursor		&& assigned a reference to frxCursor object by client container.
		*p: ocommondlg
		*p: transparency		&& 1=Opaque, 2=Transparent, 3=Use Alpha Channel
		*p: useexplicitfontcharset
	*</DefinedPropArrayMethod>

	alphafill = 255
	alphapen = 255
	backcolor = 0		&& Specifies the background color used to display text and graphics in an object.
	backstyle = 1		&& Specifies if the background of an object is transparent or opaque.
	defaultbackcolor = .F.
	defaultforecolor = .F.
	fontcharset = 1		&& Specifies the script for the font used to display text.
	fontface = ("")
	fontsize = 0		&& Specifies the font size for text displayed with an object.
	fontstrikethru = .F.		&& Specifies if the text is strikethru.
	fontstyle = 0		&& Specifies the style of a control.
	fontunderline = .F.		&& Specifies if the text is underlined.
	forecolor = 0		&& Specifies the foreground color used to display text and graphics in an object.
	frxcursor = (.NULL.)		&& assigned a reference to frxCursor object by client container.
	Height = 16
	Name = "frxformatutil"
	ocommondlg = .NULL.
	transparency = 1		&& 1=Opaque, 2=Transparent, 3=Use Alpha Channel
	useexplicitfontcharset = .F.
	Width = 66
	
	PROCEDURE backcolor_access
		if THIS.DefaultBackColor
			return DEFAULT_BACK_COLOR
		else
			return THIS.BackColor
		endif
		
	ENDPROC

	PROCEDURE backstyle_access
		*-------------------------
		* BackStyle_Access
		*-------------------------
		* 0 = transparent
		* 1 = opaque
		return iif( this.Transparency=1, 1, 0 )
		
	ENDPROC

	PROCEDURE chartostyleflags
		*===============================================================
		* CharToStyleFlags( cBytes )
		*
		* returns the integer/binary form of 
		*
		* Example: Bold+Italic = "BI" = 1+2 = 3
		*===============================================================
		lparameter cStyle
		
		local iStyleFlags
		
		m.iStyleFlags = ;
			FRX_FONTSTYLE_NORMAL + ;
			iif( STYLE_CHAR_STRIKE $ m.cStyle, FRX_FONTSTYLE_STRIKETHROUGH, 0 ) + ;
			iif( STYLE_CHAR_UNDER  $ m.cStyle, FRX_FONTSTYLE_UNDERLINED,    0 ) + ;
			iif( STYLE_CHAR_ITALIC $ m.cStyle, FRX_FONTSTYLE_ITALIC,        0 ) + ;
			iif( STYLE_CHAR_BOLD   $ m.cStyle, FRX_FONTSTYLE_BOLD,          0 ) 
		
		return m.iStyleFlags
	ENDPROC

	PROCEDURE choosefont
		*===============================================================
		* ChooseFont()
		*
		* Push/Pops the report printer environment, then displays a 
		* font picker dialog and sets the internal object properties to 
		* match the chosen font.
		*===============================================================
		local curSel, curRec, restorePE
		curSel = select(0)
		select frx
		curRec = recno()
		go top 
		
		*---------------------------------------------------------------
		* Save current VFP default printer environment 
		* and restore the FRX one
		*---------------------------------------------------------------
		*** DH 03/30/2010: fix a bug: TAG may not be empty so check TAG2 to see if
		*** printer environment saved
		***if not empty( TAG )
		if not empty( TAG2 )
			*-------------------------------------------------
			* There is printer environment data to restore
			* in order that the list of printer fonts are correct 
			* for this report:
			*-------------------------------------------------
			restorePE = .T.
		
			THIS.frxcursor.pushPrintEnvToCursor("pe_save") 
		
			select frx
			THIS.frxCursor.popPrintEnv()
		
		else
			restorePE = .F.
		endif
		
		*---------------------------------------------------------------
		* Error occurs if .FontFace is empty. Shouldn't normally happen
		* but can happen if a non-truetype font is chosen, then 
		* Format->Font... menu used.
		*---------------------------------------------------------------
		if empty( THIS.FontFace )
			THIS.FontFace = "Arial"
		endif
		
		*---------------------------------------------------------------
		* In VFP7/8:
		*    GETFONT(,,,1) means "Script dropdown enabled, at system default value"
		*    GETFONT(,,,0) means "Script dropdown disabled, at system default value"
		*
		* In VFP9, 
		*    GETFONT(,,,-1) will explicitly selected Western.
		*
		* In FontCharSet parlance:
		*		0 = Western
		*	    1 = System Default
		*
		* Use the regular GETFONT() dialog, with the "P" switch to limit
		* the list to Printer-acceptable fonts:
		*----------------------------------------------------------------
		local cFontString
		
		if THIS.FontCharSet = 0
		*** DH 09/26/2012: wrap calls to GETFONT() with "P" switch in TRY and
		*** if it fails, retry without that switch to avoid a "printer not ready"
		*** error if there's no default printer
			try
				cFontString = getfont( ;
					THIS.FontFace, ;
					THIS.FontSize, ;
					THIS.StyleFlagsToChar( THIS.FontStyle)+"P", ;
					-1 )
			catch
				cFontString = getfont( ;
					THIS.FontFace, ;
					THIS.FontSize, ;
					THIS.StyleFlagsToChar( THIS.FontStyle), ;
					-1 )
			endtry
		else
			try
				cFontString = getfont( ;
					THIS.FontFace, ;
					THIS.FontSize, ;
					THIS.StyleFlagsToChar( THIS.FontStyle)+"P", ;
					THIS.FontCharSet )
			catch
				cFontString = getfont( ;
					THIS.FontFace, ;
					THIS.FontSize, ;
					THIS.StyleFlagsToChar( THIS.FontStyle), ;
					THIS.FontCharSet )
			endtry
		endif
		
		*---------------------------------------------------------------
		* Save the current font decoration settings. These aren't supported 
		* by the GETFONT() dialog, and will get overwritten by the SetFont() 
		* call below:
		*---------------------------------------------------------------
		local llStrikethru, llUnderline
		llStrikeThru = THIS.FontStrikeThru
		llUnderline  = THIS.FontUnderline
		
		*---------------------------------------------------------------
		* GETFONT() returns a string, so convert it into individual
		* font attributes for internal storage:
		*---------------------------------------------------------------
		if not empty( m.cFontString )
			THIS.setFont( m.cFontString )
		endif
		
		*---------------------------------------------------------------
		* Re-apply the additional font decoration:
		*---------------------------------------------------------------
		if m.llStrikeThru
			THIS.FontStyle = THIS.FontStyle + FRX_FONTSTYLE_STRIKETHROUGH
		endif
		if m.llUnderline
			THIS.FontStyle = THIS.FontStyle + FRX_FONTSTYLE_UNDERLINED
		endif
		
		*---------------------------------------------------------------
		* Restore the printer environment
		*---------------------------------------------------------------
		if m.restorePE
			select pe_save
			THIS.frxCursor.popPrintEnv()
			use in pe_save
		endif
		
		go (m.curRec) in frx
		select (m.curSel)
		return 
	ENDPROC

	PROCEDURE fontmetric		&& Parameter: iMetricIndex. Returns the fontmetric for the current internal font.
		*======================================================================
		* FontMetric( iMetricIndex )
		*
		* Wraps FONTMETRIC() to return the fontmetric for the current font:
		*======================================================================
		lparameter iMetric
		return fontmetric( m.iMetric, THIS.FontFace, THIS.FontSize, THIS.StyleFlagsToChar( THIS.FontStyle ) )
		
		
	ENDPROC

	PROCEDURE fontstrikethru_access
		*------------------------
		* FontStrikeThru_Access
		*------------------------
		return bittest( this.FontStyle, 7 )
		
	ENDPROC

	PROCEDURE fontstrikethru_assign
		*------------------------
		* FontStrikeThru_assign 
		*------------------------
		lparameter lStrike
		if m.lStrike
			this.FontStyle = bitset( this.FontStyle, 7 )	
		else
			this.FontStyle = bitclear( this.FontStyle, 7 )	
		endif
		
	ENDPROC

	PROCEDURE fontunderline_access
		*------------------------
		* FontUnderline_Access
		*------------------------
		return bittest( this.FontStyle, 2 )
		
	ENDPROC

	PROCEDURE fontunderline_assign
		*------------------------
		* FontUnderline_Assign 
		*------------------------
		lparameter lUnder
		if m.lUnder
			this.FontStyle = bitset( this.FontStyle, 2 )	
		else
			this.FontStyle = bitclear( this.FontStyle, 2 )	
		endif
		
	ENDPROC

	PROCEDURE forecolor_access
		if THIS.DefaultForeColor
			return DEFAULT_FORE_COLOR
		else
			return THIS.ForeColor
		endif
		
	ENDPROC

	PROCEDURE getbackcolor
		*===============================================================
		* GetBackColor( rgb [, g, b ] )
		* 
		* Color PEMS:
		* -------------------------------
		* .SetBackColor( rgb [, g, b ] )
		* .SetForeColor( rgb [, g, b ] )
		* .GetForeColor( [cComponent] )
		* .GetBackColor( [cComponent] )
		* .ForeColor
		* .BackColor
		*
		* Color Rules:
		* ------------------------
		* .ForeColor, .BackColor will always return a valid composite RGB integer.
		* .GetForeColor('R') returns -1 if default is being used, else red component
		* .GetBackColor('G') returns -1 if default is being used, else green component
		* .GetBackColor()    returns -1 if default is being used, else RBG composite.
		*
		*===============================================================
		lparameters cRGB
		
		do case
		case THIS.DefaultBackColor
			return -1
		
		case empty( m.cRGB )
			return THIS.BackColor
		
		case upper(m.cRGB) = "R"
			return mod(THIS.BackColor,256)
			
		case upper(m.cRGB) = "G"
			return mod(int(THIS.BackColor/256),256)
			
		case upper(m.cRGB) = "B"
			return mod(int(THIS.BackColor/(256*256)),256)
			
		endcase
		
	ENDPROC

	PROCEDURE getfontstring
		*===============================================================
		* GetFontString()
		* 
		* Returns the internal representation of the font attributes
		* as a string, similar to what you would see in a getfont
		* read-only textbox+button combination:
		*
		*   "Courier,10,B"
		*===============================================================
		if inlist(THIS.FontCharSet, 1, -1 ) ;
		or not THIS.UseExplicitFontCharset
			*-------------------------------------------------
			* For System Default, don't show the charset
			*-------------------------------------------------
			return	THIS.FontFace + ", " + ;
					trans(THIS.FontSize) + ", " + ;
					THIS.StyleFlagsToChar( THIS.FontStyle ) 
		else	
			return	THIS.FontFace + ", " + ;
					trans(THIS.FontSize) + ", " + ;
					THIS.StyleFlagsToChar( THIS.FontStyle ) + ", " + ;
					trans(THIS.FontCharSet)
		endif
	ENDPROC

	PROCEDURE getforecolor
		*===============================================================
		* GetForeColor( rgb [, g, b ] )
		* 
		* Color PEMS:
		* -------------------------------
		* .SetBackColor( rgb [, g, b ] )
		* .SetForeColor( rgb [, g, b ] )
		* .GetForeColor( [cComponent] )
		* .GetBackColor( [cComponent] )
		* .ForeColor
		* .BackColor
		*
		* Color Rules:
		* ------------------------
		* .ForeColor, .BackColor will always return a valid composite RGB integer.
		* .GetForeColor('R') returns -1 if default is being used, else red component
		* .GetBackColor('G') returns -1 if default is being used, else green component
		* .GetBackColor()    returns -1 if default is being used, else RBG composite.
		*
		*===============================================================
		lparameters cRGB
		
		do case
		case THIS.DefaultForeColor
			return -1
		
		case empty( m.cRGB )
			return THIS.ForeColor
		
		case upper(m.cRGB) = "R"
			return mod(THIS.ForeColor,256)
			
		case upper(m.cRGB) = "G"
			return mod(int(THIS.ForeColor/256),256)
			
		case upper(m.cRGB) = "B"
			return mod(int(THIS.ForeColor/(256*256)),256)
			
		endcase
		
	ENDPROC

	PROCEDURE isfontbold
		*===============================================================
		* IsFontBold( [ int ] )
		*
		* returns .T. if the current .FontStyle attribute has the BOLD 
		* flag set.
		* Can also be called on a specific set of Style flags.
		*===============================================================
		lparameter iStyle
		if parameters()<1
			iStyle = THIS.FontStyle
		endif
		return bittest( m.iStyle, 0 )
	ENDPROC

	PROCEDURE isfontitalic
		*===============================================================
		* IsFontItalic( [ int ] )
		*
		* returns .T. if the current .FontStyle attribute has the ITALIC
		* flag set.
		* Can also be called on a specific set of Style flags.
		*===============================================================
		lparameter iStyle
		if parameters()<1
			iStyle = THIS.FontStyle
		endif
		return bittest( m.iStyle, 1 )
	ENDPROC

	PROCEDURE setbackcolor
		*===============================================================
		* SetBackColor( rgb [, g, b ] )
		* 
		* Color PEMS:
		* -------------------------------
		* .SetBackColor( rgb [, g, b ] )
		* .SetForeColor( rgb [, g, b ] )
		* .GetForeColor( [cComponent] )
		* .GetBackColor( [cComponent] )
		* .ForeColor
		* .BackColor
		*
		* Color Rules:
		* ------------------------
		* .ForeColor, .BackColor will always return a valid composite RGB integer.
		* .GetForeColor('R') returns -1 if default is being used, else red component
		* .GetBackColor('G') returns -1 if default is being used, else green component
		* .GetBackColor()    returns -1 if default is being used, else RBG composite.
		*
		*===============================================================
		lparameters iRgb, iGreen, iBlue
		
		if m.iRgb = -1
			*---------------------------------
			* Use the default back color:
			*---------------------------------
			THIS.DefaultBackColor = .T.
			THIS.BackColor = DEFAULT_BACK_COLOR
		else
			*---------------------------------
			* Use the passed value(s):
			*---------------------------------
			THIS.DefaultBackColor = .F.	
			if pcount() = 3
				THIS.BackColor = m.iRgb + (m.iGreen*256) + (m.iBlue*256*256)
			else
				THIS.BackColor = m.iRgb
			endif	
		endif
		
	ENDPROC

	PROCEDURE setfont		&& parameters: cFontString ( from getFont())     Sets the internal properties ...
		*===============================================================
		* SetFont( [ cTypeface [, iSize [, vStyle [, iCharset ]]]] )
		*
		* OR:
		*
		* SetFont( cTypeface , iSize , vStyle , lDouble, iResoid )
		*
		* sets the internal font attributes from the current FRX record
		* or specific passed values.
		*===============================================================
		lparameters cFontFace, iSize, vStyle, vDouble, iResoid
		
		local iParamCount, iCharset, iStyle
		iParamCount = parameters()
		
		if m.iParamCount = 0 and used('frx')
			*---------------------------------------------------------------
			* populate the five parameters from the current FRX record:
			*---------------------------------------------------------------
			cFontFace = trim( frx.FONTFACE )
			iSize     = int( frx.FONTSIZE )
			iStyle    = int( frx.FONTSTYLE )
			vDouble   = frx.DOUBLE
			iResoid   = int( frx.RESOID )
			iParamCount = 5
		endif
		
		
		if m.iParamCount = 5
			*-------------------------------------
			* DOUBLE and RESOID were passed in.
			* Convert to a single iCharSet value:
			*-------------------------------------
			*-----------------------------------------------------------------
			* FontCharSet:
			*-----------------------------------------------------------------
			* In VFP7/8:
			*    GETFONT(,,,1) means "Script dropdown enabled, at system default value"
			*    GETFONT(,,,0) means "Script dropdown disabled, at system default value"
			*
			* In VFP9, 
			*    GETFONT(,,,-1) will explicitly selected Western.
			*
			* In FontCharSet parlance:
			*		0 = Western
			*	    1 = System Default
			*
			* in the FRX:
			*   frx.DOUBLE indicates if an explicit FontCharSet is specified
			*   frx.RESOID contains the value of FontCharSet
			*
			* The following instructions match the behavior that will occur 
			* from the Format menu:
			*
			* -- DOUBLE = .T. and RESOID = 0: then the Builder should 
			*    pass a -1 to explicitly select Western script in the dialog.  
			*
			* -- DOUBLE = .T. and RESOID # 0: then the Builder should 
			*    pass the value in ResoID to the dialog.
			*
			* -- DOUBLE = .F., the Builder should disregard any stray value 
			*    in ResoID and always pass a 1.  This will bring up the 
			*    dialog at the default script for the locale but allow other 
			*    scripts to be selected.
			*-----------------------------------------------------------------
			if m.vDouble
				do case
				case m.iResoid = 0
					*-----------------------------------------------------------------
					* -- DOUBLE = .T. and RESOID = 0: then the Builder should 
					*    pass a -1 to explicitly select Western script in the dialog. 
					*    See THIS.ChooseFont(). 
					*-----------------------------------------------------------------
			*		iCharset = -1
					iCharset = 0
					THIS.UseExplicitFontCharset = .T.
		
				case m.iResoid = 1			
					*-----------------------------------------------------------------
					* -- DOUBLE = .T. and RESOID =1:  then the Builder should 
					*    pass the value in ResoID to the dialog, and note that we're
					*    using the system default charset:
					*-----------------------------------------------------------------
					iCharset = 1
					THIS.UseExplicitFontCharset = .F.
		
				otherwise
					*-----------------------------------------------------------------
					* -- DOUBLE = .T. and RESOID # 0: then the Builder should 
					*    pass the value in ResoID to the dialog.
					*-----------------------------------------------------------------
					iCharset = m.iResoid
					THIS.UseExplicitFontCharset = .T.
		
				endcase
			else
				*-----------------------------------------------------------------
				* DOUBLE= .F. : No charset info - so use system default:
				*-----------------------------------------------------------------
				iCharset = 1
				THIS.UseExplicitFontCharset = .F.
			endif
		
			*------------------------------------------
			* Pretend there were only four parameters:
			*------------------------------------------
			iParamCount = 4
		
		else
			* Less than 5 params. So put iCharset back:
			iCharset    = m.vDouble
		endif
		
		*---------------------------------------------------------------
		* Parameters could be:
		* 
		*	 "Times New Roman" 
		*	 "Times New Roman", 10
		*    "Times New Roman", 10, "BIU-"
		*    "Times New Roman", 10, 135
		*    "Times New Roman", 10, "N", 255
		*---------------------------------------------------------------
		do case
		case m.iParamCount = 1
			*---------------------------------------------------------------
			* See THIS.ChooseFont() method.
			* Assume it's the result of a GETFONT() i.e. "Courier New,10,B,72"
			* and parse out the components:
			*---------------------------------------------------------------
			cFontFace = strtran(m.cFontFace,", ",",")
		
			local comma1, comma2, comma3
			comma1 = at( ",", m.cFontFace, 1)
			comma2 = at( ",", m.cFontFace, 2)
			comma3 = at( ",", m.cFontFace, 3)
		
			if m.comma3 > 0
				*---------------------------------------------------------------
				* Extract the charset:
				*---------------------------------------------------------------
				iCharset = int(val( substr( m.cFontFace, m.comma3+1 ) ))
				cFontFace = left( m.cFontFace, m.comma3-1 )
				THIS.UseExplicitFontCharset = .T.
			else
				iCharset = 1  && No charset info - so use system default:
				THIS.UseExplicitFontCharset = .F.
			endif
		
			if m.comma2 > 0
				*---------------------------------------------------------------
				* Extract the Style:
				*---------------------------------------------------------------
				iStyle = THIS.CharToStyleFlags( substr( m.cFontFace, m.comma2+1 ) )
				cFontFace = left( m.cFontFace, m.comma2-1 )
			else
				iStyle = FRX_FONTSTYLE_NORMAL
			endif
					
			if m.comma1 > 0
				*---------------------------------------------------------------
				* Extract the Size:
				*---------------------------------------------------------------
				iSize = int( val( substr( m.cFontFace, m.comma1+1 ) ))
				cFontFace = left( m.cFontFace, m.comma1-1 )
			else
				iSize = FRX_FONTSIZE_DEFAULT
			endif
		
		
		case m.iParamCount = 2
			*---------------------------------------------------------------
			* Just face and size:
			*---------------------------------------------------------------
			iStyle    = FRX_FONTSTYLE_NORMAL
			iCharset  = 1
		
		
		case m.iParamCount > 2
		
			if m.iParamCount < 4
				m.iCharset  = 1
			endif
			
			do case
			case type("m.vStyle") = "N"
				iStyle = m.vStyle
				
			case type("m.vStyle") = "C"
				iStyle = THIS.CharToStyleFlags( m.vStyle )
			
			otherwise
				iStyle = FRX_FONTSTYLE_NORMAL
		
			endcase
					
		endcase
		
		THIS.FontFace    = m.cFontFace
		THIS.FontSize    = m.iSize
		THIS.FontStyle   = m.iStyle
		THIS.FontCharSet = m.iCharset
		
		return
	ENDPROC

	PROCEDURE setforecolor
		*===============================================================
		* SetForeColor( rgb [, g, b ] )
		* 
		* Color PEMS:
		* -------------------------------
		* .SetBackColor( rgb [, g, b ] )
		* .SetForeColor( rgb [, g, b ] )
		* .GetForeColor( [cComponent] )
		* .GetBackColor( [cComponent] )
		* .ForeColor
		* .BackColor
		*
		* Color Rules:
		* ------------------------
		* .ForeColor, .BackColor will always return a valid composite RGB integer.
		* .GetForeColor('R') returns -1 if default is being used, else red component
		* .GetBackColor('G') returns -1 if default is being used, else green component
		* .GetBackColor()    returns -1 if default is being used, else RBG composite.
		*
		*===============================================================
		lparameters iRgb, iGreen, iBlue
		
		if m.iRgb = -1
			*---------------------------------
			* Use the default fore color:
			*---------------------------------
			THIS.DefaultForeColor = .T.
			THIS.ForeColor = DEFAULT_FORE_COLOR
		else
			*---------------------------------
			* Use the passed value(s):
			*---------------------------------
			THIS.DefaultForeColor = .F.	
			if pcount() = 3
				THIS.ForeColor = m.iRgb + (m.iGreen*256) + (m.iBlue*256*256)
			else
				THIS.ForeColor = m.iRgb
			endif	
		endif
		
	ENDPROC

	PROCEDURE styleflagstochar
		*===============================================================
		* StyleFlagsToChar( iStyle )
		*
		* Returns a character string representing all Typeface attributes
		* set in a specific integer value of flags, e.g.:
		*
		* 135 = 1+2+4+128 = "BIU-"
		*===============================================================
		lparameter iStyle
		
		cStyle = ""
		if THIS.isFontBold( m.iStyle )
			cStyle = m.cStyle + STYLE_CHAR_BOLD
		endif
		if THIS.isFontItalic( m.iStyle )
			cStyle = m.cStyle + STYLE_CHAR_ITALIC
		endif
		if THIS.FontUnderline
			cStyle = m.cStyle + STYLE_CHAR_UNDER
		endif
		if THIS.FontStrikeThru
			cStyle = m.cStyle + STYLE_CHAR_STRIKE
		endif
		
		if empty( m.cStyle )
			cStyle = STYLE_CHAR_NORMAL
		endif
		
		return m.cStyle
	ENDPROC

	PROCEDURE transparency_assign
		lparameter liValue
		THIS.Transparency = m.liValue
		do case
		case liValue = 1
			THIS.AlphaFill = 255
		
		case liValue = 2
			THIS.AlphaFill = 0
		
		endcase
		
	ENDPROC

	PROCEDURE txtwidth		&& Wraps TXTWIDTH() to yield the result with respect to the current font. Parameter: cString
		*======================================================================
		* TxtWidth( cString )
		*
		* Wraps TXTWIDTH() to return the fontmetric for the current font:
		*======================================================================
		lparameter cString
		return txtwidth( m.cString, THIS.FontFace, THIS.FontSize, THIS.StyleFlagsToChar( THIS.FontStyle ) )
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxhandlerform AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: canceltofrx
		*m: contextmenuhit
		*m: execute		&& Parameter: oHelper. Handles the report builder event as specified by oHelper.
		*m: isinstanceof		&& Parameters:( cClass, oObjRef )  Returns: .T. | .F.
		*m: loadfromfrx		&& put code here that reads values from the frx and sets control values appropriately. Called from .Execute().
		*m: resizeandalign
		*m: savetofrx		&& Put code that writes changes to the temporary FRX cursor. Called from the OK button.
		*p: errored
		*p: frxevent		&& The execute method should assign the passed oEvent reference here for easy access.
		*p: hasadditionaltabs
		*p: pagetoactivate
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	BorderStyle = 2
	Desktop = .T.
	DoCreate = .T.
	errored = .F.
	frxevent = .NULL.		&& The execute method should assign the passed oEvent reference here for easy access.
	hasadditionaltabs = .F.
	Height = 254
	MaxButton = .F.
	MinButton = .F.
	Name = "frxhandlerform"
	pagetoactivate = 0
	Width = 371
	WindowState = 0
	WindowType = 1
	grabber.Height = 11
	grabber.Left = 92
	grabber.Name = "grabber"
	grabber.Top = 224
	grabber.Width = 11
	frxcursor.Name = "frxcursor"

	ADD OBJECT 'cmdCancel' AS cmd WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 208, ;
		Name = "cmdCancel", ;
		Top = 220
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS cmd WITH ;
		Caption = "Help", ;
		Left = 288, ;
		Name = "cmdHelp", ;
		Top = 220
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS cmd WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 128, ;
		Name = "cmdOK", ;
		Top = 220
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />
	
	PROCEDURE canceltofrx
		*=======================================================================
		* CancelToFrx()
		*
		* Discard all changes made to the FRX - if any.
		*
		* In this method, we iterate through the container objects, calling 
		* their .CanceltoFRX() methods.
		*=======================================================================
		local i, j, oControl, oPage
		
		*-------------------------------------------------------------
		* Just in case anything thinks the xbase code is the bottleneck:
		*-------------------------------------------------------------
		if DEBUG_WAITMSG_WHILE_EXECUTING
			wait window "Builder cleanup..." nowait
		endif
		
		*-------------------------------------------------------------
		* Call each panel's CancelToFrx() method:
		*-------------------------------------------------------------
		if type("THIS.frame") = "O" and ;
		   upper(THIS.frame.BaseClass)="PAGEFRAME"
		   
			for i = 1 to THIS.Frame.PageCount
				oPage = THIS.Frame.Pages(m.i)
		
				for j = 1 to oPage.ControlCount
					oControl = oPage.Controls(m.j)
					if pemstatus(oControl,"CancelToFrx",5)
						oControl.CancelToFrx()
					endif
					oControl = .NULL.
				endfor
				oPage = .NULL.
			endfor
			
		endif
		
		*-------------------------------------------------------------
		* TODO: perhaps create a frxEvent::CancelToFrx() method?
		*-------------------------------------------------------------
		with THIS.frxEvent
		
			if .eventType = FRX_BLDR_EVENT_OBJECTCREATE
		
				select frx
				locate for UNIQUEID = .UNIQUEID
				delete
				
				*-------------------------------------------
				* Ensure the change we just made is saved:
				*-------------------------------------------
				.setReloadChanges(.T.)
		
			endif
		
			.setHandledByBuilder(.T.)
		
		endwith
		return
		
	ENDPROC

	PROCEDURE contextmenuhit
		*=======================================================================
		* ContextMenuHit( cAction )
		*
		* Perform the action appropriate to the bar of the context menu.
		* (See HandlerContextMenu.MNX)
		*=======================================================================
		lparameter cAction
		
		do case
		case m.cAction = "DEBUG_SAVE_NATIVE"
			*----------------------------------------------------------
			* Save changes, then invoked the default, native dialog:
			*----------------------------------------------------------
			if THIS.SaveToFrx()
				THIS.frxEvent.setReloadChanges(.T.)
				THIS.frxEvent.setHandledByBuilder(.F.)
				THIS.Hide()
			endif
			
		case m.cAction = "DEBUG_DISCARD_NATIVE" 
			*----------------------------------------------------------
			* Discard changes, then invoked the default, native dialog:
			*----------------------------------------------------------
			THIS.CancelToFrx()
			THIS.frxEvent.setReloadChanges(.F.)
			THIS.frxEvent.setHandledByBuilder(.F.)
			THIS.Hide()
			
		case m.cAction = "EVENT_INSPECTOR"
			local x
			x = newobject("EventHookAlert", HANDLERS_PRG_CLASSLIB )
			x.Execute( THIS.frxEvent )
		
		case m.cAction = "MEMBER_BROWSE"
			THIS.frxEvent.browseMetadata()
		
		case m.cAction = "MEMBER_EDIT"
			THIS.frxEvent.editXmlMetadata()
			
		case m.cAction = "BROWSE_FRX"
			THIS.frxEvent.browseFrx()
		
		case m.cAction = "OPTIONS"
			THIS.frxEvent.showOptions()
		
		endcase
		
		
	ENDPROC

	PROCEDURE Error
		*=======================================================================
		* Error()
		*
		* The superclass method, frxBaseForm::Error(), has code in it to deal 
		* with error events defered up the containership hierachy to this level, 
		* but here, in frxHandlerForm, we need to ensure that when an error occurs,
		* we don't actually *Cancel* (we could be in the middle of a third-party
		* application). We should close the dialog and set the flags so that no
		* changes are saved and the event is NOT passed back to the Designer:
		*=======================================================================
		lparameters iError, cMethod, iLine
		if THIS.Errored
			return
		endif
		local x
		x = newobject("ErrorHandler", FRXUTILS_PRG_CLASSLIB )
		x.Handle( m.iError, m.cMethod, m.iLine, THIS )
		do case
		case x.cancelled
			THIS.Errored = .T.
			THIS.frxEvent.setReloadChanges(.F.)
			THIS.frxEvent.setHandledByBuilder(.T.)
		
			if this.Visible
				THIS.Hide()
			endif
			
		case x.suspended
			activate window debug
			suspend
		endcase
		
		return
		
	ENDPROC

	PROCEDURE execute		&& Parameter: oHelper. Handles the report builder event as specified by oHelper.
		*=======================================================================
		* Execute( oEvent )
		*
		* This is the main/only method of the event handler interface. It takes 
		* an event represented by an object (of class frxEvent, see frxEvent.prg)
		* and "processes" it, however it sees fit. Its only requirement is to 
		* set the .returnFlags property on the object reference before terminating.
		*
		* In this class, the .Execute() event must load data from the FRX cursor, 
		* show itself (modally), then save data back to the FRX cursor before 
		* returning control to the higher level program that invoked it.
		*=======================================================================
		lparameters oEvent
		
		THIS.Errored = .F.
		
		*----------------------------------------------------------------
		* Save the event reference in a property for easy access:
		*----------------------------------------------------------------
		THIS.frxEvent = m.oEvent
		
		*----------------------------------------------------------------
		* Read values from the FRX:
		*----------------------------------------------------------------
		if THIS.loadFromFrx()
		
			*----------------------------------------------------------------
			* At some point, someone may claim that XBase code is causing 
			* a sluggishness when using the Report Designer. This compile-time
			* constant controls the appearance of the "Loading..." & "Saving..." 
			* messages:
			*----------------------------------------------------------------
			if DEBUG_WAITMSG_WHILE_EXECUTING
				wait clear
			endif
		
			*---------------------------------------------------------------
			* Fix for SP1:
			* Resize the page frame and align the objects on the form:	
			*---------------------------------------------------------------
			THIS.ResizeAndAlign()
		
			*----------------------------------------------------------------
			* Show the window modally:
			*----------------------------------------------------------------
			if not THIS.Errored
				if type("THIS.frame") = "O" and ;
				   upper(THIS.frame.BaseClass)="PAGEFRAME"
		
					*----------------------------------------------
					* Get around the re-draw bug that is still in 
					* the product in 1928
					*----------------------------------------------
					if THIS.PageToActivate > 0
						THIS.frame.ActivePage = THIS.PageToActivate
					endif
					
				endif
				THIS.Show(1) && modal
			endif
		
		endif
		return
	ENDPROC

	PROCEDURE Init
		*=======================================================================
		* Init()
		*
		* By default
		* Handler forms are non-resizeable by default.
		* We assume 
		*=======================================================================
		DoDefault()
		
		*---------------------------------------------------------------------
		* By default, handler forms are non-resizeable:
		*---------------------------------------------------------------------
		* Comment this line out for resizeable dialogs:
		THIS.BorderStyle = 2
		
		THIS.cmdHelp.Enabled = (set("HELP")=="ON")
		THIS.cmdHelp.Visible = SHOW_HELP_BUTTON_ON_HANDLER_FORMS
		
		
	ENDPROC

	PROCEDURE isinstanceof		&& Parameters:( cClass, oObjRef )  Returns: .T. | .F.
		*=======================================================================
		* IsInstanceOf( cClassName, object )
		*
		* Returns .T. if the specific object reference is descended from 
		* a specific class somewhere in the class tree.
		*
		* Probably a silly place to put this logic for now.
		*=======================================================================
		lparameters cClass, oRef
		
		local array aAncestors[1]
		if aclass( aAncestors, m.oRef ) > 0
			if ascan( aAncestors, upper(m.cClass) ) > 0
				return .T.
			endif
		endif
		return .F.
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		if type("THIS.frame") = "O" and ;
		   upper(THIS.frame.BaseClass)="PAGEFRAME"
		
			do case
			case m.nShiftAltCtrl = 4 and between( m.nKeyCode, 120, (THIS.frame.PageCount + 119) )
				*-----------------------------------------
				* Switch tabs based on Alt-1,2,3 etc
				*-----------------------------------------
				THIS.frame.ActivePage = (m.nKeyCode - 119)
				
			case m.nShiftAltCtrl = 2 and m.nKeyCode = 31 && Ctrl-PageUp
				keyboard "{CTRL+SHIFT+TAB}"
		
			case m.nShiftAltCtrl = 2 and m.nKeyCode = 30 && Ctrl-PgDown
				keyboard "{CTRL+TAB}"
			
			otherwise
				dodefault( m.nKeyCode, m.nShiftAltCtrl)
				
			endcase	
		endif
	ENDPROC

	PROCEDURE loadfromfrx		&& put code here that reads values from the frx and sets control values appropriately. Called from .Execute().
		*=======================================================================
		* LoadFromFrx()
		*
		* Read values in from the FRX
		*
		* In this method, we iterate through the container objects, calling 
		* their .LoadToFRX() methods.
		*=======================================================================
		local OkToContinue, i, j, oPage, oPanel
		OkToContinue = .T.
		
		*-------------------------------------------------------------
		* Remove the OK button if we are protected and read-only:
		*-------------------------------------------------------------
		if THIS.frxEvent.protected and ;
			THIS.frxEvent.frxCursor.hasProtectionFlag( ORDER, FRX_PROTECT_OBJECT_NO_EDIT)
			
			THIS.cmdOK.Visible = .F.
			with THIS.cmdCancel
				.Caption = "OK"
				.Default = .T.
				*.Top = THIS.cmdOK.Top
				*.Left = THIS.cmdOK.Left
			endwith
			
		endif			
		
		*-------------------------------------------------------------
		* ENH for SP2: Open memberdata cursor
		*-------------------------------------------------------------
		if not THIS.frxCursor.UnpackMemberData()
			THIS.frxEvent.SetHandledByBuilder(.T.)
			return .F.
		endif
		
		*-------------------------------------------------------------
		* Process each panel:
		*-------------------------------------------------------------
		if type("THIS.frame") = "O" and ;
		   upper(THIS.frame.BaseClass)="PAGEFRAME"
		
			*-------------------------------------------------------------
		   	* Enhancement for SP1: 
		   	* Add any additional tab classes registered as 'T' in Handler Registry:
			*-------------------------------------------------------------
			local curRec, curSel, cPageName
			curSel = select(0)
			select frxRegistry
			curRec = recno()
		
			scan for REC_TYPE = HANDLREG_EXTRATAB ;
		    	and inlist( EVENTTYPE, THIS.frxEvent.EventType, -1 ) ;
				and (inlist( OBJTYPE,   THIS.frxEvent.ObjType,  -1 ) ;
		        	or (OBJTYPE = FRX_OBJTYPE_LAYOUTCONTROLS AND THIS.frxcursor.IsLayoutControl(THIS.frxEvent.ObjType))) ;
				and inlist( OBJCODE,   THIS.frxEvent.ObjCode,   -1 ) ;
				and not deleted()
		
				cPageName = 'T'+sys(2015)
		
				if THIS.Frame.NewRegisteredObject( m.cPageName, trim(HNDL_CLASS),trim(HNDL_LIB))
		
					*------------------------------------------------
					* Enhancement for SP2:
					* Allow setting of PageOrder thru the FLTR_ORDR
					* column. Note that it might be C(1) or I 
					*------------------------------------------------
					if val(trans(FLTR_ORDR)) > 0	
						THIS.Frame.Pages( THIS.Frame.PageCount ).PageOrder = min(THIS.Frame.PageCount,max(1,val(trans(FLTR_ORDR))))
					endif
					THIS.HasAdditionalTabs = .T.
					
				endif
			endscan     
			go m.curRec
			select (m.curSel)
		   
			*-------------------------------------------------------------
		   	* Assign references to utility objects:
			*-------------------------------------------------------------
			for i = 1 to THIS.Frame.PageCount
				oPage = THIS.Frame.Pages(m.i)
				for j = 1 to oPage.ControlCount
					oPanel = oPage.Controls(m.j)
				
					*----------------------------------------------
					* Fix for SP1: Does not rely on panel control
					* being subclasses from frxPanel; rather, uses 
					* reflection instead:
					*----------------------------------------------
					if pemstatus( m.oPanel, "event", 5 )
						oPanel.event     = THIS.frxEvent 
					endif
					if pemstatus( m.oPanel, "frxCursor", 5 )
						oPanel.frxCursor = THIS.frxEvent.frxCursor
					endif
						
					oPanel = null
				endfor
		
				oPage = null
			endfor
		
			*----------------------------------------------------------------
			* New for SP2: Sync up the fonts if there are any new tabs
			*----------------------------------------------------------------
			if THIS.HasAdditionalTabs 
				THIS.CheckForLargeFonts()
			endif
		
			*-------------------------------------------------------------
		   	* Invoke every control's LoadFromFrx():
			*-------------------------------------------------------------
			* SP2: Delegate to the pageframe:
			*-------------------------------------------------------------
			OkToContinue = THIS.frame.LoadPanelsFromFrx()
		
			*-------------------------------------------------------------
			* Change for SP2: Remove any tabs that do not have any visible
			*                 contents (controls), rather than explicitly 
			*                 removing the page objects by name
			*-------------------------------------------------------------
			THIS.frame.RemoveUnusedPages()
		
			THIS.PageToActivate = 1
		
		endif
		
		return m.OkToContinue
		
	ENDPROC

	PROCEDURE QueryUnload
		*------------------------------------------------------------
		* Clicking on the close box is equivalent to hitting the 
		* Cancel button:
		*------------------------------------------------------------
		THIS.CancelToFrx()
		THIS.Hide()
	ENDPROC

	PROCEDURE resizeandalign
		*---------------------------------------------------------------------
		* Enhancement for SP1: New method
		* Enhancement for SP2: Improved calculation, and multi-row-tabs if 
		*                      additional tabs have been added.
		*---------------------------------------------------------------------
		if type("THIS.frame") = "O" and ;
		   upper(THIS.frame.BaseClass)="PAGEFRAME"
		
			local i, j, oPage, oControl, iScreenDPI
			iScreenDPI = this.frxCursor.ScreenDPI
		
			*-----------------------------------------------------------
			* Calculate the minimum height of the page frame based on 
			* contained control sizes and positions:
			*-----------------------------------------------------------
			local liHeightFromControlPanels, liLowestEdge
			liLowestEdge = 0
		
			for i = 1 to THIS.Frame.PageCount
				for j = 1 to THIS.Frame.Pages(m.i).ControlCount
					oControl = THIS.Frame.Pages(m.i).Controls(m.j)	
		
					liLowestEdge ;
						= max(  m.liLowestEdge, ;
								oControl.Top + oControl.Height )
					oControl = .NULL.
				endfor
			endfor
			* TODO: Does this work for different sized fonts & DPI?
			THIS.Frame.Height = m.liLowestEdge + 40	
		
			*-----------------------------------------------------------
			* Calculate the minimum width of the page frame based on 
			* contained control sizes:
			*-----------------------------------------------------------
			local liWidthFromControlPanels
			liWidthFromControlPanels = 0
		
			for i = 1 to THIS.Frame.PageCount
				for j = 1 to THIS.Frame.Pages(m.i).ControlCount
					oControl = THIS.Frame.Pages(m.i).Controls(m.j)	
		
					liWidthFromControlPanels ;
						= max(  m.liWidthFromControlPanels, ;
								oControl.Width + oControl.Left + DIALOG_SPACE )
					oControl = .NULL.
				endfor
			endfor
		
			*-----------------------------------------------------------
			* Calculate the minimum width of the page frame based on 
			* tab caption widths:
			*-----------------------------------------------------------
			local liWidthFromCaptions, liAvgCharWidth
			liWidthFromCaptions = 0
			liAvgCharWidth      = 0
		
			* Determine the new width of the page frame,
			* Using the width of each Caption to estimate it:
			*		
			for i = 1 to THIS.Frame.PageCount
				oPage = THIS.Frame.Pages(m.i)
		
				liAvgCharWidth = FONTMETRIC(6, oPage.FontName, oPage.FontSize, iif(oPage.FontBold,"B","") + iif(oPage.FontItalic,"I","") )
		
				liWidthFromCaptions = ;
					m.liWidthFromCaptions + ;
				    TXTWIDTH( oPage.Caption, oPage.FontName, oPage.FontSize, iif(oPage.FontBold,"B","") + iif(oPage.FontItalic,"I","")) * m.liAvgCharWidth
		
				* Font-independent Fudge Factor:
				*
				liWidthFromCaptions = ;
					m.liWidthFromCaptions + int( m.liAvgCharWidth * 3.2 )
				    
				oPage = .NULL.
			endfor
		
			* Account for Screen DPI (because FONTMETRIC() assumes 96 I think
			*
		*	if m.iScreenDPI <> 96
		*		liWidthFromCaptions = int( (m.liWidthFromCaptions * m.iScreenDpi) / 96 )
		*	endif
			
			*-----------------------------------------------------------
			* How many tabs require us to blip into multirow mode? 
			* Factor in:
			*   THIS.Frame.PageCount
			*   THIS.HasAdditionalTabs
			*   the two sizes
			*-----------------------------------------------------------
			local llMultiRow, liNewWidth
		
			do case
			*-----------------------------------------------------------
			* If the W(controls) is greater than W(caption) or MAX_WIDTH
			* then we should fit the frame to the controls and 
			* let the captions self-fit. W(controls) is basically 
			* the smallest the dialog can go. (We gotta see the controls!)
			*
			case (m.liWidthFromControlPanels >= m.liWidthFromCaptions) ;
			  or (m.liWidthFromControlPanels >= MAX_FRAME_WIDTH ) 
		
				llMultiRow = .F.
				liNewWidth = m.liWidthFromControlPanels
		
			*-----------------------------------------------------------
			* If the W(captions) is less than the widest frame allowed
			* by asthetics, then we can size using the captions:
			*
			case (m.liWidthFromCaptions <= MAX_FRAME_WIDTH )
		
				llMultiRow = .F.
				liNewWidth = m.liWidthFromCaptions
				
			*-----------------------------------------------------------
			* Otherwise, set the width to the W(controls) and 
			* pop into multi-row tabs:
			*
			otherwise
		
				llMultiRow = .T.
				liNewWidth = m.liWidthFromControlPanels
			
			endcase
		
			*-----------------------------------------------------------
			* Alternatively, we don't want either of these situations:
			* -- the captions are scrunched together
			* -- the control panels are obscured
			* Therefore, forget that last DO CASE block:
			*
			liNewWidth = max( m.liWidthFromControlPanels, m.liWidthFromCaptions )
			if m.liNewWidth > MAX_FRAME_WIDTH
				llMultiRow = .T.
				liNewWidth = m.liWidthFromControlPanels
			endif
			
			*---------------------------------------------------
			* Configure the page frame:
			*---------------------------------------------------
			if m.llMultiRow
				* Set frame to multi-row tabs,
				THIS.frame.TabStyle   = 0 && Justified
				THIS.frame.TabStretch = 0 && MultiRow
			endif
			
			THIS.frame.Width = m.liNewWidth
		
			*---------------------------------------------------
			* Arrange the elements on the form:
			*---------------------------------------------------
			* Assume we have 1 pageframe and 2 or 3 buttons to arrange
			* neatly:
		
			store DIALOG_SPACE to ;
				THIS.Frame.Top, ; 
				THIS.Frame.Left
					
			store THIS.Frame.Height + THIS.Frame.Top + DIALOG_SPACE to ;
				THIS.cmdOK.Top, ;
				THIS.cmdCancel.Top, ;
				THIS.cmdHelp.Top
		
			if THIS.cmdHelp.Visible
				store THIS.frame.Width + DIALOG_SPACE - THIS.cmdHelp.Width - 1 to ;
					THIS.cmdHelp.Left
		
				store THIS.cmdHelp.Left - DIALOG_SPACE - THIS.cmdCancel.Width to  ;
					THIS.cmdCancel.Left
		
				store THIS.cmdCancel.Left - DIALOG_SPACE - THIS.cmdOK.Width to  ;
					THIS.cmdOK.Left		
			else
				store THIS.frame.Width + DIALOG_SPACE - THIS.cmdCancel.Width - 1 to ;
					THIS.cmdCancel.Left
		
				store THIS.cmdCancel.Left - DIALOG_SPACE - THIS.cmdOK.Width to  ;
					THIS.cmdOK.Left		
			endif
		
			THIS.Height = THIS.cmdOK.Top + THIS.cmdOK.Height + DIALOG_SPACE		
			THIS.Width  = THIS.frame.Width + DIALOG_SPACE + DIALOG_SPACE
		
			THIS.MinWidth  = THIS.Width
			THIS.MinHeight = THIS.Height
		
			*------------------------------------
			* Must be done after the adjustments,
			* Otherwise the positional adjustments
			* made above don't take effect.
			*------------------------------------
			THIS.frame.Anchor     = 15
			THIS.cmdOK.Anchor     = 12
			THIS.cmdCancel.Anchor = 12
			THIS.cmdHelp.Anchor   = 12
			
		endif
		
	ENDPROC

	PROCEDURE RightClick
		*=======================================================================
		* RightClick()
		*
		* Show the default context menu for handler forms:
		*=======================================================================
		*--------------------------------------------------------
		* not available if MODI REPORT... PROTECTED
		*--------------------------------------------------------
		if DEBUG_RCLICK_AVAILABLE and not THIS.frxEvent.protected
		
			*--------------------------------------------------------
			* See this.ContextMenuHit()
			*--------------------------------------------------------
			oRef = THIS
			
			DEFINE POPUP shortcut ;
				SHORTCUT RELATIVE ;
				in window (THIS.Name) ;
				from mrow(THIS.Name),mcol(THIS.Name)
		
			if DEBUG_ALLOW_DEFAULT_ON_CONTEXT_MENU
				DEFINE BAR 1  OF shortcut PROMPT "[DEBUG] Save and invoke native action"
				DEFINE BAR 2  OF shortcut PROMPT "[DEBUG] Discard and invoke native action"
				DEFINE BAR 3  OF shortcut PROMPT "\-"
				ON SELECTION BAR 1  OF shortcut oRef.contextMenuHit("DEBUG_SAVE_NATIVE")
				ON SELECTION BAR 2  OF shortcut oRef.contextMenuHit("DEBUG_DISCARD_NATIVE")
			endif
		
			DEFINE BAR 4  OF shortcut PROMPT UI_CONTEXT_EVENT_INSPECTOR_LOC      && PICTRES _mti_docview
			ON SELECTION BAR 4  OF shortcut oRef.contextMenuHit("EVENT_INSPECTOR")
		
			DEFINE BAR 5  OF shortcut PROMPT "\-"
		
			*--------------------------------------------------------
			* Revised for SP2:
			*--------------------------------------------------------
			DEFINE BAR 6  OF shortcut PROMPT UI_CONTEXT_MEMBERDATA_LOC
			ON BAR 6 OF shortcut ACTIVATE POPUP memberdata
		
			DEFINE POPUP memberdata ;
				SHORTCUT RELATIVE ;
				in window (THIS.Name) ;
					
		    if used("memberdata") and reccount("memberdata") > 0
				DEFINE BAR 1 OF memberdata PROMPT UI_CONTEXT_BROWSE_MEMBER_LOC   
			else		
				DEFINE BAR 1 OF memberdata PROMPT "\"+UI_CONTEXT_BROWSE_MEMBER_LOC    
			endif
			DEFINE BAR 2 OF memberdata PROMPT UI_CONTEXT_EDIT_MEMBER_XML_LOC  && PICTRES _mwi_cmd
		
			ON SELECTION BAR 1 OF memberdata oRef.contextMenuHit("MEMBER_BROWSE")
			ON SELECTION BAR 2 OF memberdata oRef.contextMenuHit("MEMBER_EDIT")
				
			DEFINE BAR 7  OF shortcut PROMPT "\-"
		
			DEFINE BAR 8  OF shortcut PROMPT UI_CONTEXT_BROWSE_FRX_LOC
			ON SELECTION BAR 8  OF shortcut oRef.contextMenuHit("BROWSE_FRX")
		
			DEFINE BAR 9  OF shortcut PROMPT "\-"
		
			DEFINE BAR 10 OF shortcut PROMPT UI_CONTEXT_OPTIONS_DIALOG_LOC
			ON SELECTION BAR 10 OF shortcut oRef.contextMenuHit("OPTIONS")
		
			ACTIVATE POPUP shortcut
			
		endif
		
		
		
	ENDPROC

	PROCEDURE savetofrx		&& Put code that writes changes to the temporary FRX cursor. Called from the OK button.
		*=======================================================================
		* SaveToFrx()
		*
		* Write values back to the FRX
		*
		* In this method, we iterate through the container objects, calling 
		* their .SaveToFRX() methods.
		*=======================================================================
		
		*-------------------------------------------------------------
		* instrumenting the xbase code
		*-------------------------------------------------------------
		if DEBUG_WAITMSG_WHILE_EXECUTING
			wait window "Saving changes..." nowait
		endif
		
		*-------------------------------------------------------------
		* Call each panel's SaveToFrx() method:
		* This method returns .T. if ok to exit the dialog:
		*-------------------------------------------------------------
		if type("THIS.frame") = "O" and ;
		   upper(THIS.frame.BaseClass)="PAGEFRAME"
		
			if not THIS.frame.SavePanelsToFrx()
				wait clear
				return .F.
			endif
			
		endif
		
		*-------------------------------------------------------------
		* ENH for SP2: Put memberdata cursor back into the STYLE column:
		*-------------------------------------------------------------
		if THIS.frxCursor.PackupMemberData()
			if used("memberdata")
				use in memberdata
			endif
		endif
		
		*-------------------------------------------------------------
		* Set the return flags:
		*-------------------------------------------------------------
		THIS.frxEvent.setReloadChanges(.T.)
		THIS.frxEvent.setHandledByBuilder(.T.)
								  
		return .T.						 
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		*------------------------------------------------------------------
		* Discard all changes and close the form:
		*------------------------------------------------------------------
		THISFORM.CancelToFrx()
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdCancel.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CANCEL_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdHelp.Click
		*------------------------------------------------------------------
		* Launch the help, working around the PageOrder/ActivePage thingy:
		*------------------------------------------------------------------
		local iHelpId, iPage
		
		iHelpId = 0
		iPage   = THISFORM.frame.ActivePage
		
		for each oPage in THISFORM.frame.Pages
		
			if oPage.PageOrder = m.iPage
				iHelpId = oPage.HelpContextId
				exit
			endif	
		endfor
		
		if not empty( m.iHelpID )
			HELP ID (m.iHelpId) 
		endif
		return 
	ENDPROC

	PROCEDURE cmdHelp.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_HELP_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdOK.Click
		*---------------------------------------------------------------------
		* Do not close the form if the .SaveToFrx() method did not complete
		* successfully. This allows failed validation to be dealt with and 
		* corrected by ther user:
		*---------------------------------------------------------------------
		if THISFORM.SaveToFrx()
			THISFORM.Hide()
		endif
	ENDPROC

	PROCEDURE cmdOK.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_OK_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxmemoeditform AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="editBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shp2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="formatter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtHelperText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdModiComm" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: codezoom
		*m: execute
		*m: fixedwidthfont_assign
		*m: sethelpertext		&& Parameter: cString
		*p: fixedwidthfont
		*p: fontfixed
		*p: fontprop
		*p: savechanges
		*p: text		&& Returns all of the text in a text-entry area of a control.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Closable = .F.
	Desktop = .T.
	DoCreate = .T.
	fontfixed = ("Lucida Console")
	fontprop = ("Tahoma")
	Height = 242
	MinButton = .F.
	Name = "frxmemoeditform"
	savechanges = .F.
	text = ("")		&& Returns all of the text in a text-entry area of a control.
	Width = 428
	WindowType = 1
	GRABBER.Height = 11
	GRABBER.Left = 404
	GRABBER.Name = "GRABBER"
	GRABBER.Top = 216
	GRABBER.Width = 11
	frxcursor.Name = "frxcursor"

	ADD OBJECT 'cmdCancel' AS cmd WITH ;
		Anchor = 9, ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 322, ;
		Name = "cmdCancel", ;
		TabIndex = 3, ;
		Top = 36, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdFont' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "Font...", ;
		Left = 322, ;
		Name = "cmdFont", ;
		TabIndex = 4, ;
		Top = 66, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdModiComm' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "Code Zoom", ;
		Left = 322, ;
		Name = "cmdModiComm", ;
		TabIndex = 5, ;
		Top = 96, ;
		Visible = .F., ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 322, ;
		Name = "cmdOK", ;
		TabIndex = 2, ;
		Top = 6, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'editBox' AS edt WITH ;
		Anchor = 15, ;
		FontName = "Tahoma", ;
		Height = 162, ;
		Left = 6, ;
		Name = "editBox", ;
		TabIndex = 1, ;
		Top = 6, ;
		Width = 310
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'edtHelperText' AS edt WITH ;
		Anchor = 14, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		DisabledBackColor = 255,255,255, ;
		ForeColor = 128,128,128, ;
		Height = 44, ;
		Left = 12, ;
		Name = "edtHelperText", ;
		ReadOnly = .T., ;
		TabIndex = 6, ;
		TabStop = .F., ;
		Top = 184, ;
		Width = 296
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'formatter' AS frxformatutil WITH ;
		Height = 16, ;
		Left = 360, ;
		Name = "formatter", ;
		Top = 128, ;
		Width = 40
		*< END OBJECT: ClassLib="frxbuilder.vcx" BaseClass="custom" />

	ADD OBJECT 'Shp2' AS shp WITH ;
		Anchor = 14, ;
		BackColor = 255,255,255, ;
		BorderColor = 192,192,192, ;
		Curvature = 2, ;
		Height = 59, ;
		Left = 6, ;
		Name = "Shp2", ;
		Style = 0, ;
		Top = 176, ;
		Width = 310
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="shape" />
	
	PROCEDURE codezoom
		*====================================================
		* Code Zoom - put the text into a MODI COMM window
		*====================================================
		local cTmpFile, cTmpWindow
		
		cTmpFile = addbs(sys(2023))+'C'+sys(2015)+".txt"
		cTmpWindow = 'W'+sys(2015)
		
		if strtofile( THIS.editBox.Value, m.cTmpFile, 0 ) > 0
		
			define Window (m.cTmpWindow) ;
			   from 5,10 to 30,100 ;
			   system grow float nominimize zoom close ;
			   font THIS.editBox.FontName, THIS.editBox.FontSize ;
			   title THIS.Caption + " - " + lower(m.cTmpFile)
		
			push key clear
			on key label CTRL-A sys(1500, '_MED_SLCTA', '_MEDIT')
			on key label CTRL-Z SYS(1500, '_MED_UNDO',  '_MEDIT')
			on key label CTRL-X SYS(1500, '_MED_CUT',   '_MEDIT')
			on key label CTRL-C SYS(1500, '_MED_COPY',  '_MEDIT')
			on key label CTRL-V SYS(1500, '_MED_PASTE', '_MEDIT')
		
			modi comm (m.cTmpFile) window (m.cTmpWindow)  ;
			   in macdesktop nomenu 
		
			pop key
		
			if file(m.cTmpFile)
				cNewText = filetostr(m.cTmpFile)
				THIS.editbox.Value = m.cNewText
				erase (m.cTmpFile)
			endif
		
			release window (m.cTmpWindow)
		endif
		
	ENDPROC

	PROCEDURE execute
		*=====================================================================
		* Execute()
		*
		* Loads the .Text into the edit box and displays the dialog modally
		*=====================================================================
		THIS.editBox.Value = THIS.Text
		
		*------------------------------------------------------
		* Restore Preferences:
		*------------------------------------------------------
		local x, cValue
		x = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, MEMO_EDITOR_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
			x.RestoreFontState( THIS.EditBox )
		endif
		
		*------------------------------------------------------
		* Kick the anchoring in the teeth:
		*------------------------------------------------------
		for each oControl in THIS.Controls
			if vartype( oControl.Anchor ) <> "U"
				oControl.Anchor = oControl.Anchor
			endif
		endfor
		
		*------------------------------------------------------
		* Display the form:
		*------------------------------------------------------
		THIS.Show(1)
		
		*------------------------------------------------------
		* Save Preferences:
		*------------------------------------------------------
		x.SaveWindowState( THIS )
		x.SaveFontState( THIS.EditBox )
		x.SaveResource( REPORTBUILDER_RESOURCE_ID, MEMO_EDITOR_RESOURCE_NAME )
		release x
		
		if THIS.saveChanges
			THIS.Text = THIS.editBox.Value
		endif
	ENDPROC

	PROCEDURE fixedwidthfont_assign
		*----------------------------------------------
		* Change the font of the edit box
		*----------------------------------------------
		lparameter lFixedWidth
		
		THIS.FixedWidthFont = m.lFixedWidth
		if m.lFixedWidth
			THIS.editBox.FontName = THIS.fontFixed
		else
			THIS.editBox.FontName = THIS.fontProp
		endif
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		private x
		if afont(x)
			THIS.FontFixed = "Consolas"
		
			if ascan(x,"Consolas") = 0
		
				THIS.FontFixed = "Lucida Console"
		
				if ascan(x,"Lucida Console") = 0
		
					THIS.FontFixed = "Courier New"
		
				endif
			endif
		endif
		THIS.MinWidth = THIS.Width
		THIS.MinHeight = THIS.Height
	ENDPROC

	PROCEDURE QueryUnload
		THIS.Hide()
	ENDPROC

	PROCEDURE sethelpertext		&& Parameter: cString
		lparameter cText
		THIS.edtHelperText.Value = m.cText
	ENDPROC

	PROCEDURE cmdCancel.Click
		THISFORM.saveChanges = .F.
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdCancel.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CANCEL_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdFont.Click
		with THISFORM
			local cFontString
			cFontString = getfont(.editBox.Fontname, .editBox.FontSize )
			if not empty( m.cFontString )
				.Formatter.setFont( cFontString )
				.editBox.FontName   = .Formatter.FontFace
				.editBox.FontSize   = .Formatter.FontSize
				.editBox.FontBold   = .Formatter.IsFontBold()
				.editBox.FontItalic = .Formatter.IsFontItalic()
			endif
		endwith
	ENDPROC

	PROCEDURE cmdFont.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_FONT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdModiComm.Click
		THIS.Parent.CodeZoom()
	ENDPROC

	PROCEDURE cmdModiComm.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CODE_ZOOM_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdOK.Click
		THISFORM.saveChanges = .T.
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdOK.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_OK_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxmetabrowser AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Grid1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grid1.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CMD1" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: execute
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Desktop = .T.
	DoCreate = .T.
	Height = 306
	MinButton = .F.
	Name = "frxmetabrowser"
	Width = 500
	grabber.Height = 11
	grabber.Left = 488
	grabber.Name = "grabber"
	grabber.Top = 292
	grabber.Width = 11
	frxcursor.Left = 444
	frxcursor.Name = "frxcursor"
	frxcursor.Top = 288

	ADD OBJECT 'CMD1' AS cmd WITH ;
		Anchor = 8, ;
		Cancel = .T., ;
		Caption = "Close", ;
		Left = 416, ;
		Name = "CMD1", ;
		Top = 8
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Grid1' AS grid WITH ;
		Anchor = 15, ;
		ColumnCount = 2, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		GridLineColor = 192,192,192, ;
		Height = 244, ;
		Left = 4, ;
		Name = "Grid1", ;
		RowHeight = 16, ;
		Top = 40, ;
		Width = 488, ;
		Column1.FontName = "Tahoma", ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column2.FontName = "Tahoma", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2"
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'Grid1.Column1.Header1' AS header WITH ;
		Caption = "Header1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'Grid1.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Grid1.Column2.Header1' AS header WITH ;
		Caption = "Header1", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'Grid1.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Destroy
		dodefault()
		
		*--------------------------------------------------
		* Save size and position in resource:
		*--------------------------------------------------
		local x
		x = newobject("ResourceManager",FRXCOMMON_PRG_CLASSLIB)
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, METABROWSER_RESOURCE_NAME )
			x.SaveWindowState( THIS )
			x.SaveResource( REPORTBUILDER_RESOURCE_ID, METABROWSER_RESOURCE_NAME )
		endif
		release x
		
	ENDPROC

	PROCEDURE execute
		if reccount("memberdata") > 0
			local i, iColCount
			THIS.Grid1.RecordSource= "memberdata"
			iColCount = fcount("memberdata")
			THIS.Grid1.ColumnCount = m.iColCount
			for i = 1 to m.iColCount
				THIS.Grid1.Columns(m.i).ControlSource = "left(alltrim(memberdata."+field(m.i,"memberdata")+"),254)"
				THIS.Grid1.Columns(m.i).Header1.Caption = field(m.i,"memberdata")
		*		THIS.Grid1.SetAll("FontSize",8)
		*		THIS.Grid1.SetAll("FontName","Tahoma")
			endfor
		
			private x
			local lcFont
			if afont(x)
				lcFont = "Consolas"
				if ascan(x,"Consolas") = 0
					lcFont = "Lucida Console"
					if ascan(x,"Lucida Console") = 0
						lcFont = "Courier New"
					endif
				endif
			endif
			THIS.SetAll("FontName",m.lcFont,"Textbox")
			THIS.SetAll("FontName",m.lcFont,"Column")
		
			go top in memberdata
			THIS.Show(1)
		endif	
		return
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		
		THIS.MinWidth  = THIS.Width
		THIS.MinHeight = THIS.Height
		
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_METABROWSE_FORM_CAPTION_LOC
		#ENDIF
		
		*--------------------------------------------------
		* Get size and position from resource:
		*--------------------------------------------------
		local x
		x = newobject( "ResourceManager",  FRXCOMMON_PRG_CLASSLIB  )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, METABROWSER_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
		endif
		release x
		
	ENDPROC

	PROCEDURE QueryUnload
		THIS.Hide()
	ENDPROC

	PROCEDURE CMD1.Click
		THISFORM.Hide()
	ENDPROC

ENDDEFINE

DEFINE CLASS frxoptions AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shp1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgRegistry" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCopy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBrowse" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="handleMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbl1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbl2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCopy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBrowse" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="registry" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LBL3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LBL8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image1" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: execute
		*m: refreshenabledstate
		*m: refreshform
		*m: savechanges
		*m: selectregistry
		*p: event
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Caption = "Report Builder Options"
	Desktop = .T.
	DoCreate = .T.
	event = null
	Height = 452
	HelpContextID = 0
	MaxButton = .F.
	MinButton = .F.
	Name = "frxoptions"
	ShowTips = .T.
	Width = 595
	WindowType = 1
	GRABBER.Height = 11
	GRABBER.Left = 540
	GRABBER.Name = "GRABBER"
	GRABBER.Top = 428
	GRABBER.Width = 11
	GRABBER.ZOrderSet = 14
	frxcursor.Left = 512
	frxcursor.Name = "frxcursor"
	frxcursor.Top = 96

	ADD OBJECT 'cmdBrowse' AS cmd WITH ;
		Caption = "Registry \<Explorer", ;
		Height = 23, ;
		Left = 330, ;
		Name = "cmdBrowse", ;
		TabIndex = 8, ;
		Top = 414, ;
		Width = 119, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdClose' AS cmd WITH ;
		Cancel = .T., ;
		Caption = "Close", ;
		Default = .T., ;
		Left = 492, ;
		Name = "cmdClose", ;
		TabIndex = 12, ;
		Top = 12, ;
		Width = 93, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCopy' AS cmd WITH ;
		Caption = "\<Create copy", ;
		Height = 23, ;
		Left = 330, ;
		Name = "cmdCopy", ;
		TabIndex = 11, ;
		Top = 335, ;
		Width = 119, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdHelp' AS cmd WITH ;
		Caption = "Help", ;
		Left = 492, ;
		Name = "cmdHelp", ;
		TabIndex = 12, ;
		Top = 42, ;
		Width = 93, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS cmd WITH ;
		Caption = "...", ;
		Height = 22, ;
		Left = 425, ;
		Name = "cmdSelect", ;
		TabIndex = 9, ;
		Top = 244, ;
		Width = 24, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'handleMode' AS opg WITH ;
		ButtonCount = 4, ;
		Height = 120, ;
		Left = 6, ;
		Name = "handleMode", ;
		TabIndex = 3, ;
		Top = 12, ;
		Value = 1, ;
		Width = 478, ;
		ZOrderSet = 5, ;
		Opt1.Caption = "Search for a \<handler class in the registry table (see below)", ;
		Opt1.Left = 68, ;
		Opt1.Name = "Opt1", ;
		Opt1.Top = 34, ;
		Opt1.Value = 1, ;
		Opt2.Caption = "Use the \<debug handler for all events", ;
		Opt2.Left = 68, ;
		Opt2.Name = "Opt2", ;
		Opt2.Top = 55, ;
		Opt3.Caption = "Use the e\<vent inspector for all events", ;
		Opt3.Left = 68, ;
		Opt3.Name = "Opt3", ;
		Opt3.Top = 76, ;
		Opt4.Caption = "\<Ignore builder events completely", ;
		Opt4.Left = 68, ;
		Opt4.Name = "Opt4", ;
		Opt4.Top = 97
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Image1' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 19, ;
		Name = "Image1", ;
		Picture = images\wqbe.bmp, ;
		Top = 291, ;
		Width = 32, ;
		ZOrderSet = 20
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Image2' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 19, ;
		Name = "Image2", ;
		Picture = images\schtable.bmp, ;
		Top = 160, ;
		Width = 32, ;
		ZOrderSet = 19
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Image3' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 19, ;
		Name = "Image3", ;
		Picture = images\userdata.bmp, ;
		Top = 26, ;
		Width = 32, ;
		ZOrderSet = 17
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Image4' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 19, ;
		Name = "Image4", ;
		Picture = images\schbrowse.bmp, ;
		Top = 370, ;
		Width = 32, ;
		ZOrderSet = 18
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'Lbl1' AS lbl WITH ;
		Caption = " Report Designer event handling ", ;
		Left = 15, ;
		Name = "Lbl1", ;
		Style = 3, ;
		TabIndex = 1, ;
		Top = 5, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Lbl2' AS lbl WITH ;
		Caption = " Handler registry table ", ;
		Left = 16, ;
		Name = "Lbl2", ;
		Style = 3, ;
		TabIndex = 4, ;
		Top = 138, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'LBL3' AS lbl WITH ;
		BackStyle = 0, ;
		Caption = "When handling Report Designer events, the builder will:", ;
		Height = 15, ;
		Left = 64, ;
		Name = "LBL3", ;
		TabIndex = 2, ;
		Top = 26, ;
		Width = 269, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'LBL8' AS lbl WITH ;
		Caption = "(build)", ;
		ForeColor = 128,128,128, ;
		Left = 528, ;
		Name = "LBL8", ;
		TabIndex = 13, ;
		Top = 412, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblBrowse' AS lbl WITH ;
		AutoSize = .F., ;
		Caption = ("Registry Explorer provides a way for you to browse the current handler registry table, and make changes if you have appropriate permissions."), ;
		Height = 64, ;
		Left = 65, ;
		Name = "lblBrowse", ;
		TabIndex = 5, ;
		Top = 372, ;
		Width = 415, ;
		WordWrap = .T., ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblCopy' AS lbl WITH ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "If you wish to override the default mappings of handler classes to report designer events, you will need to create a customizable copy of the internal table.", ;
		Height = 65, ;
		Left = 65, ;
		Name = "lblCopy", ;
		TabIndex = 10, ;
		Top = 291, ;
		Width = 415, ;
		WordWrap = .T., ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTable' AS lbl WITH ;
		AutoSize = .F., ;
		Caption = ("The Report Builder uses a lookup table to determine which class to use to handle a specific builder event and/or object type."), ;
		Height = 35, ;
		Left = 64, ;
		Name = "lblTable", ;
		TabIndex = 5, ;
		Top = 161, ;
		Width = 416, ;
		WordWrap = .T., ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'opgRegistry' AS opg WITH ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 44, ;
		Left = 70, ;
		Name = "opgRegistry", ;
		Top = 195, ;
		Value = 1, ;
		Width = 215, ;
		ZOrderSet = 2, ;
		Opt1.Caption = "\<Use internal lookup table", ;
		Opt1.Left = 5, ;
		Opt1.Name = "optInternal", ;
		Opt1.Top = 5, ;
		Opt1.Value = 1, ;
		Opt2.Caption = "U\<se alternative lookup table:", ;
		Opt2.Left = 5, ;
		Opt2.Name = "optCustom", ;
		Opt2.Top = 26
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'registry' AS txt WITH ;
		Height = 22, ;
		Left = 93, ;
		Name = "registry", ;
		ReadOnly = .T., ;
		TabIndex = 7, ;
		Themes = .F., ;
		Top = 244, ;
		Value = Internal defaut registry table, ;
		Width = 331, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'Shp1' AS shp WITH ;
		Height = 297, ;
		Left = 7, ;
		Name = "Shp1", ;
		Style = 3, ;
		Top = 146, ;
		Width = 477, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="shape" />
	
	PROCEDURE execute
		*=======================================================================
		* Execute( oEvent )
		*
		* We're using the Handler method signature, but this is not really 
		* an OptionsHandler as such. Just makes sense to use the same method 
		* name...
		*=======================================================================
		lparameter oEvent
		
		this.event = oEvent
		
		*-----------------------------------------------------------------
		* Read the handle mode from the session data store:
		*-----------------------------------------------------------------
		this.handleMode.Value = this.Event.sessionData.get("handleMode")
		
		*-----------------------------------------------------------------
		* Read the Registry table setting:
		*-----------------------------------------------------------------
		local cFile
		cFile = this.event.getRegistryTableName()  && must be called before test below:
		
		if this.event.usingInternalRegistry
			this.opgRegistry.Value = 1
			THIS.registry.Value      = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
		else
			this.opgRegistry.Value = 2
			THIS.registry.Value      = m.cFile
		endif
		
		this.Show(1)
		
		this.SaveChanges()
		
		return
	ENDPROC

	PROCEDURE Init
		dodefault()
		THIS.BorderStyle = 2
		
		*----------------------------------------------
		* Help Settings:
		*----------------------------------------------
		THIS.HelpContextID   = UI_OPTIONS_DLG_HELP_ID
		THIS.cmdHelp.Visible = SHOW_HELP_BUTTON_ON_HANDLER_FORMS
		THIS.cmdHelp.Enabled = (set("HELP")=="ON")
		
	ENDPROC

	PROCEDURE refreshenabledstate
		*=======================================================================
		* RefreshEnabledState()
		*
		* Ensures that the controls are displaying what they are supposed to
		*=======================================================================
		local cFile
		cFile = THISFORM.event.getRegistryTableName()
		
		if THISFORM.event.usingInternalRegistry
			THIS.registry.Value      = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
			THIS.registry.Value      = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
			THIS.cmdSelect.Enabled   = .F.
		else
			THIS.registry.Value      = lower(m.cFile)
			THIS.cmdSelect.Enabled   = .T.
		endif
		
		
		if THISFORM.opgRegistry.Value = 1
			THIS.registry.Value      = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
			THIS.registry.Enabled    = .F.
			THIS.cmdSelect.Enabled   = .F.
		else
			THIS.registry.Value      = lower(m.cFile)
			THIS.cmdSelect.Enabled   = .T.
			THIS.registry.Enabled    = .T.
		endif	
		
	ENDPROC

	PROCEDURE refreshform
		
		
		if THISFORM.opgRegistry.Value = 1
			THIS.registry.Enabled    = .F.
			THIS.cmdSelect.Enabled   = .F.
		else
			THIS.cmdSelect.Enabled   = .T.
			THIS.registry.Enabled    = .T.
		endif	
		
	ENDPROC

	PROCEDURE savechanges
		*-----------------------------------------------------------------
		* Save the handle mode optioon back to the session data store:
		*-----------------------------------------------------------------
		this.Event.sessionData.set("handleMode",this.handleMode.Value)
		
		*-----------------------------------------------------------------
		* Close the Registry table if open:
		*-----------------------------------------------------------------
		local lRegWasOpen
		lRegWasOpen = used("frxregistry")
		if m.lRegWasOpen
			use in frxregistry
		endif
		
		*-----------------------------------------------------------------
		* Save the Registry table setting back to the session data store:
		*-----------------------------------------------------------------
		if THIS.opgRegistry.Value = 1
			THIS.event.sessionData.set("Registry", "*" )	
			THIS.event.usingInternalRegistry = .T.
		else
			THIS.event.sessionData.set("Registry", THIS.registry.Value )	
			THIS.event.usingInternalRegistry = .F.
		endif	
		
		*-----------------------------------------------------------------
		* Open the registry if it was previously open:
		*-----------------------------------------------------------------
		if m.lRegWasOpen
			THIS.Event.OpenRegistry()
		endif
		
	ENDPROC

	PROCEDURE selectregistry
	ENDPROC

	PROCEDURE cmdBrowse.Click
		*----------------------------------------------------------------
		* The event object knows how to display a Registry Browser
		*----------------------------------------------------------------
		THISFORM.SaveChanges()
		THISFORM.event.browseRegistry()
		
	ENDPROC

	PROCEDURE cmdBrowse.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_CMD_EXPLORE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdClose.Click
		*-----------------------------------------------------------------
		* Code will continue executing after the .Show() in .Execute()
		*-----------------------------------------------------------------
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdClose.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CLOSE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdCopy.Click
		*----------------------------------------------------------------
		* The event object knows how to copy the internal registry 
		* table out to an external file:
		*----------------------------------------------------------------
		THISFORM.event.CopyRegistry()
		
		*-----------------------------------------------------------------
		* re-read the Registry table setting:
		*-----------------------------------------------------------------
		local cFile
		cFile = THISFORM.event.getRegistryTableName()  && must be called before test below:
		
		if THISFORM.event.usingInternalRegistry
			THISFORM.opgRegistry.Value = 1
			THISFORM.registry.Value      = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
		else
			THISFORM.opgRegistry.Value = 2
			THISFORM.registry.Value      = m.cFile
		endif
		
		
		THISFORM.RefreshForm()
		
	ENDPROC

	PROCEDURE cmdCopy.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_CMD_COPY_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdHelp.Click
		HELP ID (THISFORM.HelpContextID)
	ENDPROC

	PROCEDURE cmdHelp.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_HELP_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdSelect.Click
		*----------------------------------------------------------------
		* The event object knows how to switch to a specific handler 
		* registry table
		*----------------------------------------------------------------
		local cRegTable
		cRegTable = getfile("DBF",OPTIONS_HANDLER_REGISTRY_PROMPT_LOC,"",0,OPTIONS_GETFILE_REGISTRY_TITLE_LOC)
		cRegTable = lower(m.cRegTable)
		do case
		case empty( m.cRegTable ) 
			*----------------------------------------------------------
			* Leave unchanged, they pressed cancel
			*----------------------------------------------------------
		
		case "untitled.dbf" $ m.cRegTable
			*----------------------------------------------------------
			* They hit the None button, so switch back to 
			* the default internal file (or path)
			*----------------------------------------------------------
			THISFORM.opgRegistry.Value = 1
			THISFORM.registry.Value = OPTIONS_DEFAULT_INTERNAL_LOOKUP_LOC
			THISFORM.RefreshForm()
			
		case not file( m.cRegTable )
			*----------------------------------------------------------
			* File not found. Warn them, but leave unchanged
			*----------------------------------------------------------
			=messagebox(OPTIONS_HANDLER_REGISTRY_INVALID_LOC, 64, DEFAULT_MBOX_TITLE_LOC)
		
		otherwise
			*----------------------------------------------------------
			* Check that it has the right structure:
			*----------------------------------------------------------
			use (m.cRegTable) in 0 shared again alias testreg
			if empty(field("rec_type",  "testreg")) ;
			or empty(field("hndl_class","testreg")) ;
			or empty(field("hndl_lib",  "testreg")) ;
			or empty(field("eventtype", "testreg")) ;
			or empty(field("objtype",   "testreg")) ;
			or empty(field("objcode",   "testreg")) ;
			or empty(field("debug",     "testreg")) ;
			or empty(field("native",    "testreg")) ;
			or empty(field("fltr_ordr", "testreg"))
			
				=messagebox(OPTIONS_HANDLER_REGISTRY_INVALID_LOC, 64, DEFAULT_MBOX_TITLE_LOC)
		
			else
				*----------------------------------------------------------
				* Use the specified table for this session:
				*----------------------------------------------------------
				THISFORM.registry.value = m.cRegTable 
				THISFORM.RefreshForm()
			endif
			use in testreg
			
		endcase
		
		
	ENDPROC

	PROCEDURE handleMode.Opt1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_SEARCH_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE handleMode.Opt2.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_DEBUG_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE handleMode.Opt3.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_INSPECT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE handleMode.Opt4.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_IGNORE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE Lbl1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_EVENT_HANDLING_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE Lbl2.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_HANDLER_TABLE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE LBL3.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_HANDLE_TEXT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE LBL8.Init
		*----------------------------------------------------
		* For final release we'll make this invisible
		*----------------------------------------------------
		if type("SHOW_APPLICATION_VERSION") = "U"
			THIS.Visible = .F.
		endif
		THIS.Caption = BUILDER_VERSION
	ENDPROC

	PROCEDURE lblBrowse.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_EXPLORE_TEXT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE lblCopy.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_COPY_TEXT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE lblTable.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_LBL_TABLE_TEXT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE opgRegistry.InteractiveChange
		THISFORM.RefreshForm()
	ENDPROC

	PROCEDURE opgRegistry.optCustom.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_USE_ALTERNATE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE opgRegistry.optInternal.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_OPTIONS_OPT_USE_INTERNAL_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxregbrowser AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdReg" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colEvent.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colEvent.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colID.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colID.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colType.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colCode.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colCode.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colDebug.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colDebug.Chk1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colNative.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colNative.Chk1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colClass.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colClass.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colLibrary.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colLibrary.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colHType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colHType.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colFilterOrder.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdReg.colFilterOrder.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cntregfilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblsearchlog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdimport" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: addrecord
		*m: execute
		*m: importfromtable
		*m: setindexto
		*m: showhelpbox
		*p: event
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	BorderStyle = 3
	Caption = "Event Handler Registry"
	DataSession = 1
	Desktop = .T.
	DoCreate = .T.
	event = .NULL.
	Height = 253
	KeyPreview = .T.
	MinButton = .F.
	Name = "frxregbrowser"
	Width = 644
	WindowType = 1
	GRABBER.Height = 11
	GRABBER.Left = 428
	GRABBER.Name = "GRABBER"
	GRABBER.Top = 224
	GRABBER.Width = 11
	frxcursor.Left = 296
	frxcursor.Name = "frxcursor"
	frxcursor.Top = 216

	ADD OBJECT 'cmdAdd' AS cmd WITH ;
		Anchor = 6, ;
		Caption = "Add Record", ;
		Left = 8, ;
		Name = "cmdAdd", ;
		TabIndex = 2, ;
		Top = 216, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdClose' AS cmd WITH ;
		Anchor = 12, ;
		Caption = "Close", ;
		Left = 536, ;
		Name = "cmdClose", ;
		TabIndex = 4, ;
		Top = 216, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdimport' AS cmd WITH ;
		Anchor = 6, ;
		Caption = "Import", ;
		Left = 116, ;
		Name = "cmdimport", ;
		TabIndex = 3, ;
		Top = 216, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cntregfilter' AS cntregfilter WITH ;
		Height = 30, ;
		Left = 6, ;
		Name = "Cntregfilter", ;
		TabIndex = 5, ;
		Top = 4, ;
		Width = 440, ;
		cboFilter.Name = "cboFilter"
		*< END OBJECT: ClassLib="frxbuilder.vcx" BaseClass="container" />

	ADD OBJECT 'grdReg' AS grid WITH ;
		Anchor = 15, ;
		ColumnCount = 10, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		GridLines = 0, ;
		HeaderHeight = 21, ;
		Height = 173, ;
		HighlightRow = .F., ;
		HighlightStyle = 1, ;
		Left = 8, ;
		Name = "grdReg", ;
		Panel = 1, ;
		RecordSource = "frxregistry", ;
		RecordSourceType = 1, ;
		RowHeight = 16, ;
		TabIndex = 1, ;
		Top = 36, ;
		Width = 629, ;
		Column1.ColumnOrder = 4, ;
		Column1.ControlSource = "NOTES", ;
		Column1.FontName = "Tahoma", ;
		Column1.FontSize = 8, ;
		Column1.Name = "colEvent", ;
		Column1.Width = 138, ;
		Column2.ColumnOrder = 5, ;
		Column2.ControlSource = "EVENTTYPE", ;
		Column2.FontName = "Tahoma", ;
		Column2.FontSize = 8, ;
		Column2.Name = "colID", ;
		Column2.Width = 32, ;
		Column3.ColumnOrder = 6, ;
		Column3.ControlSource = "OBJTYPE", ;
		Column3.FontName = "Tahoma", ;
		Column3.FontSize = 8, ;
		Column3.Name = "colType", ;
		Column3.Width = 35, ;
		Column4.ColumnOrder = 7, ;
		Column4.ControlSource = "OBJCODE", ;
		Column4.FontName = "Tahoma", ;
		Column4.FontSize = 8, ;
		Column4.Name = "colCode", ;
		Column4.Width = 35, ;
		Column5.ColumnOrder = 9, ;
		Column5.ControlSource = "DEBUG", ;
		Column5.FontName = "Tahoma", ;
		Column5.FontSize = 8, ;
		Column5.Name = "colDebug", ;
		Column5.Sparse = .F., ;
		Column5.Width = 39, ;
		Column6.ColumnOrder = 8, ;
		Column6.ControlSource = "NATIVE", ;
		Column6.FontName = "Tahoma", ;
		Column6.FontSize = 8, ;
		Column6.Name = "colNative", ;
		Column6.Sparse = .F., ;
		Column6.Width = 39, ;
		Column7.ColumnOrder = 2, ;
		Column7.ControlSource = "HNDL_CLASS", ;
		Column7.FontName = "Tahoma", ;
		Column7.FontSize = 8, ;
		Column7.Name = "colClass", ;
		Column7.Width = 108, ;
		Column8.ColumnOrder = 3, ;
		Column8.ControlSource = "HNDL_LIB", ;
		Column8.FontName = "Tahoma", ;
		Column8.FontSize = 8, ;
		Column8.Name = "colLibrary", ;
		Column8.Width = 121, ;
		Column9.Alignment = 2, ;
		Column9.ColumnOrder = 1, ;
		Column9.ControlSource = "REC_TYPE", ;
		Column9.FontName = "Tahoma", ;
		Column9.FontSize = 8, ;
		Column9.InputMask = "", ;
		Column9.Name = "colHType", ;
		Column9.Width = 49, ;
		Column10.ControlSource = "FLTR_ORDR", ;
		Column10.FontName = "Tahoma", ;
		Column10.FontSize = 8, ;
		Column10.Name = "colFilterOrder", ;
		Column10.Width = 53
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'grdReg.colClass.Header1' AS header WITH ;
		Caption = "Class", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colClass.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colCode.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Objcode", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colCode.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colDebug.Chk1' AS chk WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		Caption = "", ;
		Left = 14, ;
		Name = "Chk1", ;
		SpecialEffect = 1, ;
		Top = 20
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdReg.colDebug.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Debug", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colEvent.Header1' AS header WITH ;
		Caption = "Description", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colEvent.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colFilterOrder.Header1' AS header WITH ;
		Caption = "Filter order", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colFilterOrder.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colHType.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Type", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colHType.Text1' AS textbox WITH ;
		Alignment = 2, ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colID.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Event", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colID.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colLibrary.Header1' AS header WITH ;
		Caption = "Library", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colLibrary.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdReg.colNative.Chk1' AS chk WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		Caption = "", ;
		Left = 10, ;
		Name = "Chk1", ;
		SpecialEffect = 1, ;
		Top = 24
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdReg.colNative.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Native", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colType.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Objtyp", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdReg.colType.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'lblsearchlog' AS lbl WITH ;
		Caption = "How was this registry table chosen?", ;
		FontUnderline = .T., ;
		ForeColor = 0,0,255, ;
		Left = 296, ;
		MousePointer = 15, ;
		Name = "lblsearchlog", ;
		TabIndex = 6, ;
		ToolTipText = "This is a tooltip", ;
		Top = 12
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />
	
	PROCEDURE addrecord
		append Blank in frxregistry
		THISFORM.grdReg.SetFocus()
		*THISFORM.grdReg.colHType.Text1.SetFocus()  
		
	ENDPROC

	PROCEDURE Destroy
		dodefault()
		
		*--------------------------------------------------
		* Save size and position in resource:
		*--------------------------------------------------
		local x
		x = newobject("ResourceManager",FRXCOMMON_PRG_CLASSLIB)
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, REGEXPLORER_RESOURCE_NAME )
			x.SaveWindowState( THIS )
			x.SaveResource( REPORTBUILDER_RESOURCE_ID, REGEXPLORER_RESOURCE_NAME )
		endif
		release x
		
	ENDPROC

	PROCEDURE execute
		lparameters oEvent
		THIS.event = m.oEvent
		
		if this.event.usingInternalRegistry
			THIS.lblSearchLog.Visible = .T.
		else
			THIS.lblSearchLog.Visible = .T.
		endif
		
		
		*-----------------------------
		* Fix for SP1:
		* If deleted is ON, turn it off
		* for the duration
		*-----------------------------
		local llSetDeleted
		llSetDeletedOn = .F.
		
		if set("DELETED")= "ON"
			llSetDeletedOn = .T.
			set deleted off
		endif
		
		THIS.cntRegFilter.RefreshParent()
			
		THIS.Show(1)
		
		THIS.SetIndexTo("")
		
		THIS.event = .null.
		
		set filter to in frxregistry
		
		if m.llSetDeletedOn
			set deleted on
		endif
	ENDPROC

	PROCEDURE importfromtable
		local cRegTable
		cRegTable = getfile("DBF",OPTIONS_HANDLER_REGISTRY_PROMPT_LOC,"",0,OPTIONS_GETFILE_REGISTRY_TITLE_LOC)
		cRegTable = lower(m.cRegTable)
		do case
		case empty( m.cRegTable ) 
			*----------------------------------------------------------
			* Leave unchanged, they pressed cancel
			*----------------------------------------------------------
		
		case "untitled.dbf" $ m.cRegTable
			*----------------------------------------------------------
			* Leave unchanged, they hit the None button
			*----------------------------------------------------------
			
		case not file( m.cRegTable )
			*----------------------------------------------------------
			* File not found. Warn them, but leave unchanged
			*----------------------------------------------------------
			=messagebox(OPTIONS_HANDLER_REGISTRY_INVALID_LOC, 64, DEFAULT_MBOX_TITLE_LOC)
		
		otherwise
			*----------------------------------------------------------
			* Check that it has the right structure:
			*----------------------------------------------------------
			use (m.cRegTable) in 0 shared again alias testreg
			if empty(field("rec_type",  "testreg")) ;
			or empty(field("hndl_class","testreg")) ;
			or empty(field("hndl_lib",  "testreg")) ;
			or empty(field("eventtype", "testreg")) ;
			or empty(field("objtype",   "testreg")) ;
			or empty(field("objcode",   "testreg")) ;
			or empty(field("debug",     "testreg")) ;
			or empty(field("native",    "testreg")) ;
			or empty(field("fltr_ordr", "testreg"))
			
				=messagebox(OPTIONS_HANDLER_REGISTRY_INVALID_LOC, 64, DEFAULT_MBOX_TITLE_LOC)
		
			else
				*----------------------------------------------------------
				* Import the specfied table:
				*----------------------------------------------------------
				select frxregistry
				append from dbf("testreg")
				THIS.grdReg.Refresh()
			endif
			
			use in testreg
			
		endcase
		
		
	ENDPROC

	PROCEDURE Init
		*=======================================================================
		* Init()
		*
		* Detect if the current table is read-only, and if so, prevent record
		* editing in the grid
		*=======================================================================
		dodefault()
		
		THIS.MinWidth  = THIS.Width
		THIS.MinHeight = THIS.Height
		
		if isreadonly("frxRegistry")
			store .F. to ;
				THIS.cmdAdd.Enabled, ;
				THIS.cmdImport.Enabled, ;
				THIS.grdReg.AllowCellSelection, ;
				THIS.grdReg.DeleteMark
		endif
		
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_FORM_CAPTION_LOC
		#ENDIF
		
		THIS.HelpContextID = UI_REGEXPLR_DLG_HELP_ID
		
		THIS.Caption = THIS.Caption + " - " + lower(displaypath(dbf("frxRegistry"),50))
		
		*--------------------------------------------------
		* Get size and position from resource:
		*--------------------------------------------------
		local x
		x = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, REGEXPLORER_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
		endif
		release x
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters iKey, iMod
		do case
		case m.iKey=25 and m.iMod=2
			*---------------------------
			* Ctrl-Y
			*---------------------------
			nodefault
			THISFORM.AddRecord()
			
		endcase
		
	ENDPROC

	PROCEDURE setindexto
		lparameters cOrder
		
		select frxregistry
		
		if not empty(set("INDEX"))
			set index to
		endif
		
		cIdxFile = addbs(sys(2023))+"frxregistry.idx"
		if file(m.cIdxFile)
			erase (m.cIdxFile)
		endif
		
		if not empty(m.cOrder)
			index on &cOrder to (m.cIdxFile)
			THIS.grdReg.Refresh()
		endif
		
		
	ENDPROC

	PROCEDURE showhelpbox
		lparameter tcColumn
		local cText
		cText = ""
		
		if tcColumn = "EventType" and ;
		   THIS.Cntregfilter.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_PROPERTIES
		   m.tcColumn = "PropertyType"
		endif   
		
		do case
		case tcColumn = "ObjectType"
			cText = REGEXPLR_OBJTYPE_HELP_TITLE_LOC + chr(13) ;
			      + chr(13) ;
				  + "-1" + chr(9) + "= " + REGEXPLR_TARGET_ANY_OBJTYPE_LOC + chr(13) ;
			      + chr(13) ;
				  + "1"  + chr(9) + "= " + TARGET_REPORT_GLOBAL_LOC + chr(13) ;
				  + "5"  + chr(9) + "= " + TARGET_TEXT_LABEL_LOC + chr(13) ;
				  + "6"  + chr(9) + "= " + TARGET_LINE_LOC + chr(13) ;
				  + "7"  + chr(9) + "= " + TARGET_BOX_LOC + chr(13) ;
				  + "8"  + chr(9) + "= " + TARGET_FIELD_LOC + chr(13) ;
				  + "17" + chr(9) + "= " + TARGET_PICTURE_LOC + chr(13) ;
			      + chr(13) ;
				  + "9"  + chr(9) + "= " + alltrim(DLG_TITLE_BAND_LOC) + chr(13) ;
			      + chr(13) ;
				  + "10" + chr(9) + "= " + TARGET_GROUPED_LOC + chr(13) ;
				  + "99" + chr(9) + "= " + TARGET_MULTISELECT_LOC + chr(13) ;
				  + "55" + chr(9) + "= " + TARGET_LAYOUT_ELEMENTS_LOC 
		
		case tcColumn = "ObjectCode"
			cText = REGEXPLR_OBJCODE_HELP_TITLE_LOC	 + chr(13) ;
			      + chr(13) ;
				  + "-1" + chr(9) + "= " + REGEXPLR_TARGET_ANY_OBJCODE_LOC + chr(13) ;
			      + chr(13) ;
			      + "53" + chr(9) + "= " + TARGET_REPORT_GLOBAL_LOC + chr(13) ;
				  + "0"  + chr(9) + "= " + REGEXPLR_TARGET_LAYOUT_ELEMENT_LOC + chr(13) ;
				  + "4"  + chr(9) + "= " + TARGET_BOX_LOC + chr(13) ;	
			      + chr(13) ;
				  + "1"  + chr(9) + "= " + TARGET_PAGE_HEADER_LOC + DLG_TITLE_BAND_LOC + chr(13)  ;
				  + "2"  + chr(9) + "= " + TARGET_COL_HEADER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "3"  + chr(9) + "= " + TARGET_GROUP_HEADER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "9"  + chr(9) + "= " + TARGET_DETAIL_HEADER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "4"  + chr(9) + "= " + TARGET_DETAIL_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "10" + chr(9) + "= " + TARGET_DETAIL_FOOTER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "5"  + chr(9) + "= " + TARGET_GROUP_FOOTER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "6"  + chr(9) + "= " + TARGET_COL_FOOTER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "7"  + chr(9) + "= " + TARGET_PAGE_FOOTER_LOC + DLG_TITLE_BAND_LOC + chr(13) ;
				  + "8"  + chr(9) + "= " + TARGET_SUMMARY_LOC + DLG_TITLE_BAND_LOC 
		
		case tcColumn = "RecordType"
			cText = REGEXPLR_RECTYPE_HELP_TITLE_LOC + chr(13) +;
			      + chr(13) ;
				  + "H"  +  " = " + REGEXPLR_RECTYPE_HANDLER_LOC + chr(13) ;
				  + "F"  +  " = " + REGEXPLR_RECTYPE_EVENTFILTER_LOC + chr(13) ;
				  + "X"  +  " = " + REGEXPLR_RECTYPE_EXITHANDLER_LOC + chr(13) ;
			      + chr(13) ;
				  + "G"  +  " = " + REGEXPLR_RECTYPE_GETEXPR_LOC + chr(13) ;
				  + "E"  +  " = " + REGEXPLR_RECTYPE_EXTENDEDIT_LOC + chr(13) ;
				  + "Y"  +  " = " + REGEXPLR_RECTYPE_REGEDIT_LOC + chr(13) ;
				  + "B"  +  " = " + REGEXPLR_RECTYPE_FRXBROWSE_LOC + chr(13) ;
				  + "Z"  +  " = " + REGEXPLR_RECTYPE_METABROWSER_LOC + chr(13) ;
			      + chr(13) ;
				  + "T"  +  " = " + REGEXPLR_RECTYPE_EXTRATAB_LOC + chr(13) ;
			      + chr(13) ;
				  + "P"  +  " = " + REGEXPLR_RECTYPE_PROPERTYDEF_LOC + chr(13) ;
				  + "Q"  +  " = " + REGEXPLR_RECTYPE_MULTIPROPDEF_LOC
		
		case tcColumn = "PropertyType"
			cText = REGEXPLR_PROPDEF_HELP_TITLE_LOC	+ chr(13) +;
			      + chr(13) ;
				  + "0"  +  " = " + ADVPROP_EDITMODE_GETEXPR_LOC + chr(13) ;
				  + "1"  +  " = " + ADVPROP_EDITMODE_GETEXPR_LOC + chr(13) ;
				  + "2"  +  " = " + ADVPROP_EDITMODE_TEXT_LOC + chr(13) ;
				  + "3"  +  " = " + ADVPROP_EDITMODE_STRING_LOC + chr(13) ;
				  + "4"  +  " = " + ADVPROP_EDITMODE_GETFILE_LOC + chr(13) ;
				  + "5"  +  " = " + ADVPROP_EDITMODE_BOOLEAN_LOC 
		
		case tcColumn = "EventType"
			cText = REGEXPLR_EVTYP_HELP_TITLE_LOC+chr(13) ;
			      + chr(13) ;
			      + "-1" + chr(9) + "= " + REGEXPLR_EVTYP_WILD_CARD_LOC + chr(13) ;
			      + chr(13) ;
			      + "1"  + chr(9) + "= " + EVTYP_PROPERTIES_LOC + chr(13) ;
			      + "2"  + chr(9) + "= " + EVTYP_OBJECT_CREATE_LOC + chr(13) ;
			      + "4"  + chr(9) + "= " + EVTYP_OBJECT_REMOVE_LOC + chr(13) ;
			      + "5"  + chr(9) + "= " + EVTYP_OBJECT_PASTE_LOC + chr(13) ;
			      + "14" + chr(9) + "= " + EVTYP_EDIT_IN_PLACE_LOC + chr(13) ;
			      + "16" + chr(9) + "= " + EVTYP_OBJECT_DROP_LOC + chr(13) ;
			      + chr(13) ;
			      + "6"  + chr(9) + "= " + EVTYP_REPORT_SAVE_LOC + chr(13) ;
			      + "7"  + chr(9) + "= " + EVTYP_REPORT_OPEN_LOC + chr(13) ;
			      + "8"  + chr(9) + "= " + EVTYP_REPORT_CLOSE_LOC + chr(13) ;
			      + chr(13) ;
			      + "9"  + chr(9) + "= " + EVTYP_DATAENV_LOC + chr(13) ;
			      + "10" + chr(9) + "= " + EVTYP_PRINT_PREVIEW_LOC + chr(13) ;
			      + "11" + chr(9) + "= " + EVTYP_OPTIONAL_BANDS_LOC + chr(13) ;
			      + "12" + chr(9) + "= " + EVTYP_DATA_GROUPING_LOC + chr(13) ;
			      + "13" + chr(9) + "= " + EVTYP_VARIABLES_LOC + chr(13) ;
			      + "15" + chr(9) + "= " + EVTYP_SET_GRID_SCALE_LOC + chr(13) ;
			      + "17" + chr(9) + "= " + EVTYP_IMPORT_DE_LOC + chr(13) ;
			      + "18" + chr(9) + "= " + EVTYP_PRINT_LOC + chr(13) ;
			      + "19" + chr(9) + "= " + EVTYP_QUICKREPORT_LOC 
		
		otherwise
			cText = "unknown column"
		
		endcase
		=messagebox( m.cText,0,DEFAULT_MBOX_TITLE_LOC)
	ENDPROC

	PROCEDURE cmdAdd.Click
		THISFORM.AddRecord()
	ENDPROC

	PROCEDURE cmdAdd.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_ADD_RECORD_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdClose.Click
		*----------------------------------------
		* Fix for SP1 but it's my own dam' fault
		*----------------------------------------
		*THISFORM.Release()
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmdClose.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CLOSE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdimport.Click
		THISFORM.ImportFromTable()
	ENDPROC

	PROCEDURE cmdimport.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_CMD_IMPORT 
		#ENDIF
		
	ENDPROC

	PROCEDURE Cntregfilter.refreshparent
		THIS.Parent.grdReg.SetAll("Visible",.T.,"Column")
		
		do case
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_HANDLERS
			store .F. to ;
				THIS.Parent.grdReg.colFilterOrder.Visible
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_FILTERS
			store .F. to ;
				THIS.Parent.grdReg.colID.Visible, ;
				THIS.Parent.grdReg.colCode.Visible, ;
				THIS.Parent.grdReg.colType.Visible, ;
				THIS.Parent.grdReg.colNative.Visible, ;
				THIS.Parent.grdReg.colDebug.Visible
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_EXIT
			store .F. to ;
				THIS.Parent.grdReg.colID.Visible, ;
				THIS.Parent.grdReg.colCode.Visible, ;
				THIS.Parent.grdReg.colType.Visible, ;
				THIS.Parent.grdReg.colNative.Visible, ;
				THIS.Parent.grdReg.colDebug.Visible
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_DIALOGS
			store .F. to ;
				THIS.Parent.grdReg.colNative.Visible, ;
				THIS.Parent.grdReg.colDebug.Visible
		
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_PROPERTIES
			store .F. to ;
				THIS.Parent.grdReg.colDebug.Visible, ;
				THIS.Parent.grdReg.colNative.Visible
		
		endcase
		
		do case
		case this.cboFilter.Value = UI_REGEXPLR_FILTER_ENU_PROPERTIES
		
			THIS.Parent.grdReg.colClass.Header1.Caption       = UI_REGEXPLR_COL_PROPNAME_LOC  
			THIS.Parent.grdReg.colLibrary.Header1.Caption     = UI_REGEXPLR_COL_PROPVALUE_LOC
			THIS.Parent.grdReg.colID.Header1.Caption          = UI_REGEXPLR_COL_PROPTYPE_LOC
			THIS.Parent.grdReg.colNative.Header1.Caption      = UI_REGEXPLR_COL_PROPHIDDEN_LOC
		
		otherwise
			THIS.Parent.grdReg.colClass.Header1.Caption       = UI_REGEXPLR_COL_CLASS_LOC  
			THIS.Parent.grdReg.colLibrary.Header1.Caption     = UI_REGEXPLR_COL_LIBRARY_LOC
			THIS.Parent.grdReg.colID.Header1.Caption          = UI_REGEXPLR_COL_EVENT_LOC
			THIS.Parent.grdReg.colNative.Header1.Caption      = UI_REGEXPLR_COL_NATIVE_LOC
		
		endcase
		
		THIS.Parent.SetIndexTo("")
		THIS.Parent.grdReg.Refresh() 
		THIS.Parent.grdReg.SetFocus() 
		THIS.Parent.GrdReg.AutoFit()
		if THIS.Parent.GrdReg.colClass.Width < 35
			THIS.Parent.GrdReg.SetAll("Width",75,"Column") 
		endif
		
		
	ENDPROC

	PROCEDURE grdReg.colClass.Header1.Click
		THISFORM.SetIndexTo("HNDL_CLASS")
	ENDPROC

	PROCEDURE grdReg.colClass.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_CLASS_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colCode.Header1.Click
		THISFORM.ShowHelpBox("ObjectCode")
	ENDPROC

	PROCEDURE grdReg.colCode.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_OBJCOD_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colDebug.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_DEBUG_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colEvent.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_DESCRIPT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colFilterOrder.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_FILTER_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colHType.Header1.Click
		THISFORM.ShowHelpBox("RecordType")
	ENDPROC

	PROCEDURE grdReg.colHType.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_TYPE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colID.Header1.Click
		THISFORM.ShowHelpBox("EventType")
	ENDPROC

	PROCEDURE grdReg.colID.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_EVENT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colID.Header1.RightClick
		THISFORM.SetIndexTo("EVENTTYPE")
	ENDPROC

	PROCEDURE grdReg.colLibrary.Header1.Click
		THISFORM.SetIndexTo("HNDL_LIB")
	ENDPROC

	PROCEDURE grdReg.colLibrary.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_LIBRARY_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colNative.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_NATIVE_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colType.Header1.Click
		THISFORM.ShowHelpBox("ObjectType")
	ENDPROC

	PROCEDURE grdReg.colType.Header1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGEXPLR_COL_OBJTYP_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE grdReg.colType.Header1.RightClick
		THISFORM.SetIndexTo("OBJTYPE")
	ENDPROC

	PROCEDURE lblsearchlog.Click
		THIS.ForeColor = RGB(128,0,128)
		=messagebox(thisform.event.SetupUtils.registrylocationlog,64,DEFAULT_MBOX_TITLE_LOC)
	ENDPROC

	PROCEDURE lblsearchlog.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_REGISTRY_SEARCH_LOG_LINK_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxruntimeeditor AS frxbaseform OF "frxbuilder.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="editBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmnOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmnCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shp2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="expExecuteWhen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LBL1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbl2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdZoom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="formatter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtHelperText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdModiComm" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: codezoom
		*m: commitcontrols
		*m: editmetaxml
		*m: execute
		*m: fixedwidthfont_assign
		*m: refreshcontrols
		*m: sethelpertext		&& Parameter: cString
		*p: checksum
		*p: event
		*p: execwhen
		*p: fixedwidthfont
		*p: fontfixed
		*p: fontprop
		*p: ometadata
		*p: savechanges
		*p: text		&& Returns all of the text in a text-entry area of a control.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 3
	Caption = "Run-time extensions"
	checksum = ("")
	Closable = .F.
	Desktop = .T.
	DoCreate = .T.
	event = .NULL.
	execwhen = ("")
	fontfixed = ("Lucida Console")
	fontprop = ("Tahoma")
	Height = 313
	MinButton = .F.
	Name = "frxruntimeeditor"
	ometadata = .NULL.
	savechanges = .F.
	Tag = "frx"
	text = ("")		&& Returns all of the text in a text-entry area of a control.
	Width = 475
	GRABBER.Height = 11
	GRABBER.Left = 456
	GRABBER.Name = "GRABBER"
	GRABBER.Top = 288
	GRABBER.Width = 11
	frxcursor.Left = 415
	frxcursor.Name = "frxcursor"
	frxcursor.Top = 12

	ADD OBJECT 'cmdFont' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "Font...", ;
		Left = 366, ;
		Name = "cmdFont", ;
		TabIndex = 7, ;
		Top = 82, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdModiComm' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "Code Zoom", ;
		Left = 366, ;
		Name = "cmdModiComm", ;
		TabIndex = 8, ;
		Top = 114, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdZoom' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "Edit XML...", ;
		Left = 367, ;
		Name = "cmdZoom", ;
		TabIndex = 9, ;
		Top = 146, ;
		Visible = .F., ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmnCancel' AS cmd WITH ;
		Anchor = 9, ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 366, ;
		Name = "cmnCancel", ;
		TabIndex = 6, ;
		Top = 50, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmnOK' AS cmd WITH ;
		Anchor = 9, ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 366, ;
		Name = "cmnOK", ;
		TabIndex = 5, ;
		Top = 20, ;
		Width = 100
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'editBox' AS edt WITH ;
		AddLineFeeds = .F., ;
		Anchor = 15, ;
		FontName = "Tahoma", ;
		FontSize = 10, ;
		Height = 148, ;
		Left = 9, ;
		Name = "editBox", ;
		TabIndex = 2, ;
		Top = 20, ;
		Width = 350
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'edtHelperText' AS edt WITH ;
		Anchor = 14, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		DisabledBackColor = 255,255,255, ;
		ForeColor = 128,128,128, ;
		Height = 68, ;
		Left = 15, ;
		Name = "edtHelperText", ;
		ReadOnly = .T., ;
		TabIndex = 10, ;
		TabStop = .F., ;
		Top = 228, ;
		Width = 336
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="editbox" />

	ADD OBJECT 'expExecuteWhen' AS frxexpressioncontrol WITH ;
		Anchor = 14, ;
		Height = 27, ;
		Left = 8, ;
		Name = "expExecuteWhen", ;
		TabIndex = 4, ;
		Top = 186, ;
		Width = 358, ;
		txtExpression.Height = 21, ;
		txtExpression.Left = 1, ;
		txtExpression.Name = "txtExpression", ;
		txtExpression.Top = 1, ;
		txtExpression.Width = 321, ;
		cmdExprBuilder.Left = 328, ;
		cmdExprBuilder.Name = "cmdExprBuilder", ;
		cmdExprBuilder.Top = 1
		*< END OBJECT: ClassLib="frxpanels.vcx" BaseClass="container" />

	ADD OBJECT 'formatter' AS frxformatutil WITH ;
		Height = 16, ;
		Left = 380, ;
		Name = "formatter", ;
		Top = 228, ;
		Width = 40
		*< END OBJECT: ClassLib="frxbuilder.vcx" BaseClass="custom" />

	ADD OBJECT 'LBL1' AS lbl WITH ;
		Anchor = 6, ;
		BackStyle = 0, ;
		Caption = "Execute when:", ;
		Left = 9, ;
		Name = "LBL1", ;
		TabIndex = 3, ;
		Top = 170
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Lbl2' AS lbl WITH ;
		BackStyle = 0, ;
		Caption = "Run-time extensions:", ;
		Left = 9, ;
		Name = "Lbl2", ;
		TabIndex = 1, ;
		Top = 3
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Shp2' AS shp WITH ;
		Anchor = 14, ;
		BackColor = 255,255,255, ;
		BorderColor = 192,192,192, ;
		Curvature = 2, ;
		Height = 81, ;
		Left = 9, ;
		Name = "Shp2", ;
		Style = 0, ;
		Top = 221, ;
		Width = 350
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="shape" />
	
	PROCEDURE codezoom
		*====================================================
		* Code Zoom - put the text into a MODI COMM window
		*====================================================
		local cTmpFile, cTmpWindow
		
		cTmpFile = addbs(sys(2023))+'C'+sys(2015)+".txt"
		cTmpWindow = 'W'+sys(2015)
		
		if strtofile( THIS.editBox.Value, m.cTmpFile, 0 ) > 0
		
			define Window (m.cTmpWindow) ;
			   from 5,10 to 30,100 ;
			   system grow float nominimize zoom close ;
			   font THIS.editBox.FontName, THIS.editBox.FontSize ;
			   title THIS.Caption + " - " + lower(m.cTmpFile)
		
			push key clear
			on key label CTRL-A sys(1500, '_MED_SLCTA', '_MEDIT')
			on key label CTRL-Z SYS(1500, '_MED_UNDO',  '_MEDIT')
			on key label CTRL-X SYS(1500, '_MED_CUT',   '_MEDIT')
			on key label CTRL-C SYS(1500, '_MED_COPY',  '_MEDIT')
			on key label CTRL-V SYS(1500, '_MED_PASTE', '_MEDIT')
		
			modi comm (m.cTmpFile) window (m.cTmpWindow)  ;
			   in macdesktop nomenu 
		
			pop key
		
			if file(m.cTmpFile)
				cNewText = filetostr(m.cTmpFile)
				THIS.editbox.Value = m.cNewText
				erase (m.cTmpFile)
			endif
		
			release window (m.cTmpWindow)
		endif
		
	ENDPROC

	PROCEDURE commitcontrols
		*-------------------------------------------
		* ENH for SP2: Use memberdata cursor instead
		*-------------------------------------------
		if THIS.CheckSum == alltrim(THIS.editBox.Value)+alltrim(THIS.expExecuteWhen.Value)
			* No change in these two values.
			* No need to save anything.
		else
			local cursel
			cursel = select(0)
			select memberdata
			locate for TYPE=FRX_BLDR_MEMBERDATATYPE and empty(NAME)
			if not found()
				insert into memberdata ;
					( TYPE, ;
					EXECUTE, ;
					EXECWHEN ) ;
				values ;
				    ( FRX_BLDR_MEMBERDATATYPE, ;
				      trim(THIS.editbox.Value), ;
				      trim(this.expExecuteWhen.value) )
			else
				replace ;
					EXECUTE  with trim(THIS.editbox.Value), ;
					EXECWHEN with trim(this.expExecuteWhen.value) ;
					in memberdata
			endif
			select (m.cursel)
		endif
		return
		
	ENDPROC

	PROCEDURE editmetaxml
		*-------------------------------------------
		* ENH for SP2: Use memberdata cursor instead
		*-------------------------------------------
		local oForm, iSelect
		iSelect = select(0)
		oForm = newobject("frxMemoEditForm","frxBuilder.vcx")
		oForm.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		oForm.setHelperText(RUNTIME_EXT_XML_HELPER_TXT_LOC)
		oForm.cmdModiComm.Visible = .T.
		oForm.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Save the current control values into the metadata cursor:
		*------------------------------------------------------
		THIS.CommitControls()
		
		*------------------------------------------------------
		* Obtain the current full metadata in XML string form:
		*------------------------------------------------------
		local lcCurrXml, lcNewXml
		
		*--------------------------------------
		* Fix for SP2: force a "reportdata" node name
		*--------------------------------------
		select * from memberdata into cursor reportdata where not deleted()
		lcCurrXml = THIS.frxCursor.CursorToXmlStr( "reportdata" )
		use in reportdata
		
		if empty(m.lcCurrXml)
			*-------------------------------------------
			* No member data currently, so 
			* use the default template in the editor:
			*-------------------------------------------
			lcCurrXml = DEFAULT_MEMBERDATA_XML
		endif
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		oForm.Text = m.lcCurrXml
		
		*------------------------------------------------------
		* m.lcXml now has a backup of the current memberdata xml
		*------------------------------------------------------
		do while .T.
		
			oForm.Execute()
			
			lcNewXml = oForm.Text
			
			if oForm.SaveChanges
				if (m.lcNewXml = m.lcCurrXml)
					*---------------------------------
					* No changes made! Don't bother saving
					*---------------------------------
					exit
				else
					if upper(m.lcNewXml) = upper(DEFAULT_MEMBERDATA_XML)
						*---------------------------------
						* Effectively back at default, so
						* empty it out so that no records
						* are created in the memberdata cursor:
						*---------------------------------
						lcNewXml = ""
					endif
					*------------------------------------------------------
					* Rebuild the memberdata cursor:
					*------------------------------------------------------
					if not THIS.frxCursor.XmlStrToCursor( m.lcNewXml, "memberdata" )
						*------------------------------------------------------
						* Error occurred. Throw them back into the editor:
						*------------------------------------------------------
						oForm.Text = m.lcNewXml
						loop
					else
						*------------------------------------------------------
						* Refresh the controls on this form:
						*------------------------------------------------------
						THIS.RefreshControls()
						exit
					endif
				endif
			else
				*------------------------------
				* We're not saving changes
				*------------------------------
				if not used("memberdata")
					if not THIS.frxCursor.XmlStrToCursor( m.lcCurrXml, "memberdata")
						*-------------------------------------
						* Now we have serious problems...
						*-------------------------------------
						* TODO: What?
					endif
				endif
				exit
			endif
		enddo
		select (m.iSelect)
		return
		
	ENDPROC

	PROCEDURE execute
		*=====================================================================
		* Execute() - implements the Event Handler API.
		*=====================================================================
		lparameter oEvent
		
		THIS.Event = oEvent   && is this used? Potentially...
		THIS.FixedWidthFont = .T.
		
		*--------------------------------------------------------------
		* Switch workareas. FRX alias could be specified in .Tag property:
		* Assume current record is correct.
		*--------------------------------------------------------------
		local curSel
		curSel = select(0)
		
		do case
		case not empty( THIS.Tag )
			select (THIS.Tag)
			
		case used( "frx" )
			select frx
			
		otherwise
			*-------------------------------------------
			* This is an error condition
			*-------------------------------------------
			= messagebox( RUNTIME_EXT_NO_FRX_LOC,48,DEFAULT_MBOX_TITLE_LOC)
			return
			
		endcase
		
		*--------------------------------------------------------------
		* Parse the XML or use default values:
		*--------------------------------------------------------------
		THIS.RefreshControls()
		
		THIS.CheckSum = alltrim(THIS.editBox.Value)+alltrim(THIS.expExecuteWhen.Value)
		
		*--------------------------------------------------------------
		* Default values:
		*--------------------------------------------------------------
		external file MEMBERSCRIPT_DEFAULT_LOC.TXT
		if empty( THIS.CheckSum ) 
			THIS.expExecuteWhen.Value = ".F."
			THIS.editBox.Value = filetostr("MEMBERSCRIPT_DEFAULT_LOC.TXT")
		endif
		
		*--------------------------------------------------------------
		* Restore window layout preferences from resource file:
		*--------------------------------------------------------------
		local x, cValue
		x = newobject( "ResourceManager", FRXCOMMON_PRG_CLASSLIB )
		if x.LoadResource( REPORTBUILDER_RESOURCE_ID, RUNTIME_EXT_RESOURCE_NAME )
			x.RestoreWindowState( THIS )
			x.RestoreFontState( THIS.EditBox )
		endif
		
		*------------------------------------------------------
		* Kick the anchoring in the teeth:
		*------------------------------------------------------
		for each oControl in THIS.Controls
			if vartype( oControl.Anchor ) <> "U"
				oControl.Anchor = oControl.Anchor
			endif
		endfor
		
		*--------------------------------------------------------------
		* Display the form:
		*--------------------------------------------------------------
		THIS.Show(1)
		
		*--------------------------------------------------------------
		* Save window layout changes as preferences in the resource file
		*--------------------------------------------------------------
		x.SaveWindowState( THIS )
		x.SaveFontState( THIS.EditBox )
		x.SaveResource( REPORTBUILDER_RESOURCE_ID, RUNTIME_EXT_RESOURCE_NAME )
		release x
		
		*--------------------------------------------------------------
		* Save changes
		*--------------------------------------------------------------
		if THIS.saveChanges
		
			THIS.CommitControls()
		
		else
			*------------------------------------
			* Restore the original value
			*------------------------------------
			* ENH for SP2: Do not restore
			* replace STYLE with THIS.XmlOnEntry
		endif
		
		*--------------------------------------------------------------
		* Restore incoming workarea:
		*--------------------------------------------------------------
		select (m.curSel)
		return
	ENDPROC

	PROCEDURE fixedwidthfont_assign
		*----------------------------------------------
		* Change the font of the edit box
		*----------------------------------------------
		lparameter lFixedWidth
		
		THIS.FixedWidthFont = m.lFixedWidth
		if m.lFixedWidth
			THIS.editBox.FontName = THIS.fontFixed
		else
			THIS.editBox.FontName = THIS.fontProp
		endif
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		
		private x
		if afont(x)
			THIS.FontFixed = "Consolas"
		
			if ascan(x,"Consolas") = 0
		
				THIS.FontFixed = "Lucida Console"
		
				if ascan(x,"Lucida Console") = 0
		
					THIS.FontFixed = "Courier New"
		
				endif
			endif
		endif
		
		THIS.MinWidth = THIS.Width
		THIS.MinHeight = THIS.Height
		
		THIS.HelpContextID = UI_METAEDIT_DLG_HELP_ID
	ENDPROC

	PROCEDURE QueryUnload
		THIS.Hide()
	ENDPROC

	PROCEDURE refreshcontrols
		*-------------------------------------------
		* ENH for SP2: Use memberdata cursor instead
		*-------------------------------------------
		local cursel
		cursel = select(0)
		select memberdata
		locate for TYPE=FRX_BLDR_MEMBERDATATYPE ;
			   and empty(NAME)
		if found()
		*	THIS.editbox.Value        = chrtran( memberdata.EXECUTE, chr(10), chr(13) )
			THIS.editbox.Value        = alltrim(memberdata.EXECUTE)
			THIS.expExecuteWhen.Value = alltrim(memberdata.EXECWHEN)
		else
			* should be at eof((), empty values
			THIS.editbox.Value        = alltrim(memberdata.EXECUTE)
			THIS.expExecuteWhen.Value = alltrim(memberdata.EXECWHEN)
		endif
		select (m.cursel)
		
		return
		
		
	ENDPROC

	PROCEDURE sethelpertext		&& Parameter: cString
		lparameter cText
		THIS.lblHelperText.Caption = m.cText
	ENDPROC

	PROCEDURE cmdFont.Click
		with THISFORM
			local cFontString
			cFontString = getfont(.editBox.Fontname, .editBox.FontSize )
			if not empty( m.cFontString )
				.Formatter.setFont( cFontString )
				.editBox.FontName   = .Formatter.FontFace
				.editBox.FontSize   = .Formatter.FontSize
				.editBox.FontBold   = .Formatter.IsFontBold()
				.editBox.FontItalic = .Formatter.IsFontItalic()
			endif
		endwith
	ENDPROC

	PROCEDURE cmdFont.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_FONT_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdModiComm.Click
		THIS.Parent.CodeZoom()
	ENDPROC

	PROCEDURE cmdModiComm.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CODE_ZOOM_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmdZoom.Click
		THISFORM.editMetaXml()
	ENDPROC

	PROCEDURE cmdZoom.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_EDIT_XML_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmnCancel.Click
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmnCancel.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_CANCEL_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE cmnOK.Click
		THISFORM.saveChanges = .T.
		THISFORM.Hide()
	ENDPROC

	PROCEDURE cmnOK.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_CMD_OK_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE edtHelperText.Init
		THIS.Value = METADATA_HELPER_TEXT_LOC 
	ENDPROC

	PROCEDURE LBL1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_METAEDIT_LBL_EXECWHEN_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE Lbl2.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_METAEDIT_LBL_RTEXTENSION_LOC
		#ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frxunitconverter AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: getfruvalueof		&& Returns a value in FRUs of a given unit value, depending on the current setting of the .units property
		*m: getspinnerhighvalue		&& Returns the unit-appropriate maximum value for a spinner
		*m: getspinnerincrement		&& returns the unit-appropriate Increment for a spinner
		*m: getspinnerinputmask		&& returns the unit-appropriate inputMask for a spinner
		*m: getunitvalueof		&& Returns a unit value for a given value in FRUs, depending on the current setting of the .units property
		*p: units
		*p: valueinfrus
	*</DefinedPropArrayMethod>

	PROTECTED valueinfrus
	Name = "frxunitconverter"
	units = 0
	valueinfrus = 0
	
	PROCEDURE getfruvalueof		&& Returns a value in FRUs of a given unit value, depending on the current setting of the .units property
		*-------------------------------------------------
		* Return a value in FRUS for a given unit value, 
		* depending on the current setting of Units:
		*-------------------------------------------------
		lparameter nValue
		
		do case
		case THIS.units = FRX_RULER_INCHES or THIS.units = FRX_RULER_OFF
			return (m.nValue * 10000)
		
		case THIS.units = FRX_RULER_METRIC 
			return (m.nValue * 0.3937 * 10000)
		
		case THIS.units = FRX_RULER_CHARACTERS
			*---------------------------------------------------------
			* 1 char = 833.33 FRU
			* 1 char = 1/12 inch
			*---------------------------------------------------------
			return (m.nValue * 833.33)
		
		*case THIS.units = FRX_RULER_PIXELS 
		otherwise
			*---------------------------------------------------------
			* Designer fixed at 96 dpi
			*---------------------------------------------------------
			return (m.nValue * 10000/96)
		
		endcase
	ENDPROC

	PROCEDURE getspinnerhighvalue		&& Returns the unit-appropriate maximum value for a spinner
		*-------------------------------------------------
		* Return the unit-appropriate Increment for a spinner:
		*-------------------------------------------------
		do case 
		case this.units = FRX_RULER_INCHES or THIS.units = FRX_RULER_OFF
			return 999.99
		
		case this.units = FRX_RULER_METRIC
			return 999.99
		
		case this.units = FRX_RULER_CHARACTERS
			return 999.99
		
		*case this.units = FRX_RULER_PIXELS
		otherwise && pixels
			return 99999
		
		endcase	
	ENDPROC

	PROCEDURE getspinnerincrement		&& returns the unit-appropriate Increment for a spinner
		*-------------------------------------------------
		* Return the unit-appropriate Increment for a spinner:
		*-------------------------------------------------
		do case 
		case this.units = FRX_RULER_INCHES or THIS.units = FRX_RULER_OFF
			return 0.05
		
		case this.units = FRX_RULER_METRIC
			return 0.05
		
		case this.units = FRX_RULER_CHARACTERS
			return 1.00
		
		*case this.units = FRX_RULER_PIXELS
		otherwise && pixels
			return 1.00
		
		endcase	
	ENDPROC

	PROCEDURE getspinnerinputmask		&& returns the unit-appropriate inputMask for a spinner
		*-------------------------------------------------
		* Return the unit-appropriate inputMask for a spinner:
		*-------------------------------------------------
		local lcMask
		do case 
		case this.units = FRX_RULER_OFF
			lcMask = [999.999 in]
			
		case this.units = FRX_RULER_INCHES
			lcMask = [999.999 in]	
		
		case this.units = FRX_RULER_METRIC
			lcMask = [999.99 cm]
		
		case this.units = FRX_RULER_CHARACTERS
			lcMask = [999.99 ch]
		
		*case this.units = FRX_RULER_PIXELS
		otherwise && pixels
			lcMask = [99999 px]
		
		endcase	
		return m.lcMask
	ENDPROC

	PROCEDURE getunitvalueof		&& Returns a unit value for a given value in FRUs, depending on the current setting of the .units property
		*-------------------------------------------------
		* Return a unit value for a given value in FRUs,
		* depending on the current setting of Units:
		*-------------------------------------------------
		lparameter nFruValue
		
		do case
		case THIS.units = FRX_RULER_INCHES or THIS.units = FRX_RULER_OFF
			return (m.nFruValue / 10000)
		
		case THIS.units = FRX_RULER_METRIC
			return (m.nFruValue / (0.3937 * 10000))
		
		case THIS.units = FRX_RULER_CHARACTERS
			*---------------------------------------------------------
			* 1 char = 833.33 FRU
			* 1 char = 1/12 inch
			*---------------------------------------------------------
			return (m.nFruValue / 833.33)
		
		*case THIS.units = FRX_RULER_PIXELS 
		otherwise
			*---------------------------------------------------------
			* Designer fixed at 96 dpi
			*---------------------------------------------------------
			return (m.nFruValue * 96 / 10000 )
		
		endcase
	ENDPROC

	PROCEDURE Init
		*=================================================
		* Class: UnitConverter
		*
		* This class converts measurement units.
		* Usage:
		*
		*   x = newobject("UnitConverter", FRXUTILS_PRG_CLASSLIB )
		*   x.units = UNITS_METRIC
		*   ? x.getUnitValueOf( 10000 )
		*   2.540
		*   ? x.getFruValueOf( 1.0 )
		*   3937.000
		*=================================================
		
	ENDPROC

ENDDEFINE

DEFINE CLASS panelfrxbrowser AS cnt OF "frxcontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Grid1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Edit11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmd1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmd2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmd3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmd4" UniqueID="" Timestamp="" />

	#INCLUDE "frxbuilder.h"
	BorderWidth = 0
	Height = 267
	Name = "panelfrxbrowser"
	Width = 468

	ADD OBJECT 'Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 36, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "CURPOS=.T. (Object selected in layout)", ;
		ControlSource = "frx.CURPOS", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 244, ;
		Name = "Check1", ;
		TabIndex = 13, ;
		Top = 244, ;
		Width = 214
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'Cmd1' AS cmd WITH ;
		Anchor = 36, ;
		Caption = "...", ;
		Height = 22, ;
		Left = 208, ;
		Name = "Cmd1", ;
		Top = 169, ;
		Width = 24
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cmd2' AS cmd WITH ;
		Anchor = 36, ;
		Caption = "...", ;
		Height = 22, ;
		Left = 208, ;
		Name = "Cmd2", ;
		Top = 193, ;
		Width = 24
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cmd3' AS cmd WITH ;
		Anchor = 12, ;
		Caption = "...", ;
		Height = 22, ;
		Left = 440, ;
		Name = "Cmd3", ;
		Top = 145, ;
		Width = 24
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cmd4' AS cmd WITH ;
		Anchor = 36, ;
		Caption = "...", ;
		Height = 22, ;
		Left = 208, ;
		Name = "Cmd4", ;
		Top = 145, ;
		Width = 24
		*< END OBJECT: ClassLib="frxcontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Edit1' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.NAME", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit1", ;
		ScrollBars = 0, ;
		TabIndex = 2, ;
		Top = 121, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit10' AS editbox WITH ;
		Anchor = 44, ;
		ControlSource = "frx.TAG2", ;
		DisabledBackColor = 238,238,238, ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 290, ;
		Margin = 1, ;
		Name = "Edit10", ;
		ReadOnly = .T., ;
		ScrollBars = 0, ;
		TabIndex = 9, ;
		Top = 145, ;
		Width = 150
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit11' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.COMMENT", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit11", ;
		ScrollBars = 0, ;
		TabIndex = 7, ;
		Top = 241, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit2' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.EXPR", ;
		DisabledBackColor = 238,238,238, ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit2", ;
		ReadOnly = .T., ;
		ScrollBars = 0, ;
		TabIndex = 3, ;
		Top = 145, ;
		Width = 151
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit3' AS editbox WITH ;
		Anchor = 44, ;
		ControlSource = "frx.USER", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 290, ;
		Margin = 1, ;
		Name = "Edit3", ;
		ScrollBars = 0, ;
		TabIndex = 12, ;
		Top = 217, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit4' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.STYLE", ;
		DisabledBackColor = 238,238,238, ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit4", ;
		ReadOnly = .T., ;
		ScrollBars = 0, ;
		TabIndex = 4, ;
		Top = 169, ;
		Width = 151
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit5' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.PICTURE", ;
		DisabledBackColor = 238,238,238, ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit5", ;
		ReadOnly = .T., ;
		ScrollBars = 0, ;
		TabIndex = 5, ;
		Top = 193, ;
		Width = 151
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit6' AS editbox WITH ;
		Anchor = 134, ;
		ControlSource = "frx.ORDER", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 57, ;
		Margin = 1, ;
		Name = "Edit6", ;
		ScrollBars = 0, ;
		TabIndex = 6, ;
		Top = 217, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit7' AS editbox WITH ;
		Anchor = 44, ;
		ControlSource = "frx.FONTFACE", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 290, ;
		Margin = 1, ;
		Name = "Edit7", ;
		ScrollBars = 0, ;
		TabIndex = 10, ;
		Top = 169, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit8' AS editbox WITH ;
		Anchor = 44, ;
		ControlSource = "frx.SUPEXPR", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 290, ;
		Margin = 1, ;
		Name = "Edit8", ;
		ScrollBars = 0, ;
		TabIndex = 11, ;
		Top = 193, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Edit9' AS editbox WITH ;
		Anchor = 44, ;
		ControlSource = "frx.TAG", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 290, ;
		Margin = 1, ;
		Name = "Edit9", ;
		ScrollBars = 0, ;
		TabIndex = 8, ;
		Top = 121, ;
		Width = 174
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'Grid1' AS grid WITH ;
		Anchor = 15, ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		GridLines = 0, ;
		Height = 112, ;
		HighlightStyle = 2, ;
		Left = 8, ;
		Name = "Grid1", ;
		RecordMark = .F., ;
		RecordSource = "FRX", ;
		RowHeight = 15, ;
		TabIndex = 1, ;
		Top = 4, ;
		Width = 456
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'Label1' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		Caption = "NAME", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label1", ;
		Style = 0, ;
		TabIndex = 20, ;
		Top = 124, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label10' AS label WITH ;
		Alignment = 1, ;
		Anchor = 164, ;
		BackStyle = 0, ;
		Caption = "TAG2", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 233, ;
		Name = "Label10", ;
		Style = 0, ;
		TabIndex = 27, ;
		Top = 148, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label11' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		BackStyle = 0, ;
		Caption = "COMMENT", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label11", ;
		Style = 0, ;
		TabIndex = 24, ;
		Top = 244, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		Alignment = 1, ;
		Anchor = 164, ;
		BackStyle = 0, ;
		Caption = "TAG", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 233, ;
		Name = "Label2", ;
		Style = 0, ;
		TabIndex = 26, ;
		Top = 124, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		Caption = "EXPR", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label3", ;
		Style = 0, ;
		TabIndex = 25, ;
		Top = 148, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label4' AS label WITH ;
		Alignment = 1, ;
		Anchor = 164, ;
		Caption = "USER", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 233, ;
		Name = "Label4", ;
		Style = 0, ;
		TabIndex = 30, ;
		Top = 220, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label5' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		Caption = "STYLE", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label5", ;
		Style = 0, ;
		TabIndex = 21, ;
		Top = 172, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label6' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		Caption = "PICTURE", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label6", ;
		Style = 0, ;
		TabIndex = 22, ;
		Top = 196, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label7' AS label WITH ;
		Alignment = 1, ;
		Anchor = 6, ;
		BackStyle = 0, ;
		Caption = "ORDER", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 3, ;
		Name = "Label7", ;
		Style = 0, ;
		TabIndex = 23, ;
		Top = 220, ;
		Width = 50
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label8' AS label WITH ;
		Alignment = 1, ;
		Anchor = 164, ;
		BackStyle = 0, ;
		Caption = "FONTFACE", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 233, ;
		Name = "Label8", ;
		Style = 0, ;
		TabIndex = 28, ;
		Top = 172, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label9' AS label WITH ;
		Alignment = 1, ;
		Anchor = 164, ;
		BackStyle = 0, ;
		Caption = "SUPEXPR", ;
		FontName = "Trebuchet MS", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 233, ;
		Name = "Label9", ;
		Style = 0, ;
		TabIndex = 29, ;
		Top = 196, ;
		Width = 55
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE Init
		THIS.BorderWidth = 0
		if isreadonly()
			THIS.Grid1.AllowCellSelection = .F.
		endif
	ENDPROC

	PROCEDURE Check1.Init
		#IF USE_LOC_STRINGS_IN_UI
		    THIS.Caption = UI_FRXBROWS_CHK_CURPOS_LOC
		#ENDIF
		
	ENDPROC

	PROCEDURE Cmd1.Click
		local x
		x = newobject("frxMemoEditForm","frxBuilder.vcx")
		x.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		x.setHelperText(RUNTIME_EXT_XML_HELPER_TXT_LOC)
		x.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		x.Text = THIS.Parent.edit4.Value
		
		x.Execute()
		
		if x.SaveChanges
			*------------------------------------------------------
			* Save the changes, if any:
			*------------------------------------------------------
			THIS.Parent.edit4.Value = x.Text
		
		endif
		return
		
	ENDPROC

	PROCEDURE Cmd2.Click
		local x
		x = newobject("frxMemoEditForm","frxBuilder.vcx")
		x.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		x.setHelperText(FRXBROWS_MEMO_EDIT_HELPER_TXT_LOC)
		x.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		x.Text = THIS.Parent.edit5.Value
		
		x.Execute()
		
		if x.SaveChanges
			*------------------------------------------------------
			* Save the changes, if any:
			*------------------------------------------------------
			THIS.Parent.edit5.Value = x.Text
		
		endif
		return
		
	ENDPROC

	PROCEDURE Cmd3.Click
		local x
		x = newobject("frxMemoEditForm","frxBuilder.vcx")
		x.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		x.setHelperText(FRXBROWS_MEMO_EDIT_HELPER_TXT_LOC)
		x.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		x.Text = THIS.Parent.edit10.Value
		
		x.Execute()
		
		if x.SaveChanges
			*------------------------------------------------------
			* Save the changes, if any:
			*------------------------------------------------------
			THIS.Parent.edit10.Value = x.Text
		
		endif
		return
		
	ENDPROC

	PROCEDURE Cmd4.Click
		local x
		x = newobject("frxMemoEditForm","frxBuilder.vcx")
		x.Caption = EDIT_META_XML_DLG_CAPTION_LOC
		x.setHelperText(FRXBROWS_MEMO_EDIT_HELPER_TXT_LOC)
		x.FixedWidthFont = .T.
		
		*------------------------------------------------------
		* Populate the edit dialog's text area:
		*------------------------------------------------------
		x.Text = THIS.Parent.edit2.Value
		
		x.Execute()
		
		if x.SaveChanges
			*------------------------------------------------------
			* Save the changes, if any:
			*------------------------------------------------------
			THIS.Parent.edit2.Value = x.Text
		
		endif
		return
		
	ENDPROC

	PROCEDURE Grid1.AfterRowColChange
		*------------------------------------------------------------
		* It's handy having the record number visible, but we're 
		* short on space, so we're using one of the grid column header captions 
		*------------------------------------------------------------
		LPARAMETERS nColIndex
		THISFORM.Refresh()
		THIS.Columns(1).Header1.Caption = "Rec: "+transform(recno('FRX'))
	ENDPROC

	PROCEDURE Grid1.Init
		dodefault()
		
		private x
		local lcFont
		if afont(x)
			lcFont = "Consolas"
		
			if ascan(x,"Consolas") = 0
		
				lcFont = "Lucida Console"
		
				if ascan(x,"Lucida Console") = 0
		
					lcFont = "Courier New"
		
				endif
			endif
		endif
		THIS.SetAll("FontName",m.lcFont,"Textbox")
	ENDPROC

ENDDEFINE

DEFINE CLASS spnmeasurementunits AS spn OF "frxcontrols.vcx" 		&& A measurement-unit aware spinner, with built-in conversion
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "frxbuilder.h"
	*<DefinedPropArrayMethod>
		*m: highvaluefru_assign
		*m: units_access
		*m: units_assign
		*m: updateinputmask
		*m: value_access
		*m: value_assign
		*p: highvaluefru
		*p: unitconverter
		*p: units		&& 0 = FRUs,  1 = Inches,   2 = metric/cm,  3 = pixels
	*</DefinedPropArrayMethod>

	highvaluefru = -1
	InputMask = "99999.999"
	Name = "spnmeasurementunits"
	SpinnerLowValue = 0.00
	unitconverter = .NULL.
	units = 0		&& 0 = FRUs,  1 = Inches,   2 = metric/cm,  3 = pixels
	
	PROCEDURE highvaluefru_assign
		*----------------------------------------------------
		* Set the high-limit for both spinner and keyboard
		*----------------------------------------------------
		lparameter iHighValueFRU
		THIS.HighValueFRU     = m.iHighValueFRU
		THIS.SpinnerHighValue = THIS.unitConverter.getUnitValueOf( m.iHighValueFRU )
		
	ENDPROC

	PROCEDURE Init
		THIS.unitConverter = newobject("frxUnitConverter","frxBuilder.vcx")
		
	ENDPROC

	PROCEDURE LostFocus
		*----------------------------------------------------------------------------
		* Manually limit keyboard-entered values.
		* Why not use KeyboardHighValue? Because we're converting measurement units
		* in the value_assign, value_access methods, and the whole rangehigh, rangelow 
		* business gets very confused. There is probably a product bug in there 
		* somewhere, but we're not going to touch it...
		*----------------------------------------------------------------------------
		
		* THIS.Value is in FRUs (see .Value_access()):
		
		if THIS.HighValueFRU <> -1
			THIS.Value = min( THIS.HighValueFRU, THIS.Value )
		endif
		
		dodefault()
	ENDPROC

	PROCEDURE units_access
		return THIS.unitConverter.units
		
	ENDPROC

	PROCEDURE units_assign
		*=======================================================================
		* Units assign()
		*
		* Sets the type of measurement unit to display the value as.
		*=======================================================================
		lparameter iNewUnits
		
		if (m.iNewUnits = 0) or (m.iNewUnits <> THIS.units)
		
			local nValueInFRU
		
			*----------------------------------------------------
			* The .Value_Access() method will perform the conversion
			* so this value comes back in FRU:
			*----------------------------------------------------
			nValueInFRU = THIS.Value
		
			THIS.unitConverter.units = m.iNewUnits
			
			*----------------------------------------------------
			* The .Value_Assign() now uses the new units setting
			* to convert the value from FRU into the new unit type
			*----------------------------------------------------
			THIS.Value = m.nValueInFRU 
		
			THIS.updateInputMask()
		endif
		
	ENDPROC

	PROCEDURE updateinputmask
		*----------------------------------------------------
		* Set a default input mask for the type of units selected:
		*----------------------------------------------------
		THIS.InputMask         = THIS.unitConverter.getSpinnerInputMask()
		THIS.Increment         = THIS.unitConverter.getSpinnerIncrement()
		
		* These default values are not always going to be appropriate.
		* Generally speaking, upper limit values will be dictated by
		* the specific class instance situation, i.e maximum page dimensions, etc.
		*
		* THIS.KeyboardHighValue = THIS.unitConverter.getSpinnerHighValue()
		* THIS.SpinnerHighValue  = THIS.unitConverter.getSpinnerHighValue()
	ENDPROC

	PROCEDURE value_access
		*=======================================================================
		* .Value access()
		*
		* Reads out the internal value (in measurement units) by converting it
		* to FRUs before returning
		*=======================================================================
		*---------------------------------------------------------
		* internal value is in appropriate units. 
		* But we want to read out value in FRUs:
		*---------------------------------------------------------
		return THIS.unitConverter.getFruValueOf( THIS.Value )
	ENDPROC

	PROCEDURE value_assign
		*=======================================================================
		* .Value assign()
		*
		* Converts FRU value to internal unit value for display and editing
		*=======================================================================
		lparameter vValue
		*---------------------------------------------------------
		* incoming value is in FRUS. But the display value must 
		* be in valid units.
		*---------------------------------------------------------
		THIS.Value = THIS.unitConverter.getUnitValueOf( m.vValue )
		
	ENDPROC

ENDDEFINE
